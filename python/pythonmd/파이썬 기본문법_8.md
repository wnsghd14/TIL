#### 스택

- 쌓는다는 의미로서, 마치 접시를 쌓고 빼듯이 데이터를 한쪽에서만 넣고 빼는 자료구조

- 가장 마지막에 들어온 데이터가 가장 먼저 나오므로 LIFO(Last-in-First-Out, 후입선출) 방식 !

- 스택이 사용되는 곳
  
  - 뒤집기, 되돌리기, 되돌아가기
  
  - 마무리 되지 않은 일을 임시 저장할때
  
  - 괄호 매칭, 함수 호출(재귀 호출), 백트래킹, DFS(깊이 우선 탐색)

- 파이썬은 리스트(List)로 스택을 간편하게 사용할 수 있다

#### 큐(Queue)

- 한 쪽 끝에서 데이터를 넣고, 다른 한 쪽에서만 데이터를 뺄 수 있는 자료구조

- 가장 먼저 들어온 가장 먼저 나가므로 FIFO(First-in First-out, 선입선출) 방식이라고 한다.

- 리스트를 이용한 큐 자료구조의 단점
  
  - 데이터를 뺄 때 큐 안에 있는 데이터가 많은 경우 비효율적이다(O(N))
  
  - 맨 앞 데이터가 빠지면서, 리스트의 인덱스가 하나씩 당겨지기 때문이다.

- 덱(Deque, Double-Ended Queue) 자료구조
  
  - 양 방향으로 삽입과 삭제가 자유로운 큐
  
  - 덱은 양 방향 삽입, 추출이 모두 큐보다 훨씬 빠르다.

### 힙(Heap)

- 일반적인 큐(Queue)는 순서를 기준으로 가장 먼저 들어온 데이터가 가장 먼저 나가므로 FIFO(First-in First-out, 선입선출) 방식

- 우선순위 큐(Priority Queue)
  
  - 우선순위(중요도, 크기 등 순서 이외의 기준)를 기준으로 가장 **우선순위가 높은 데이터가 가장 먼저 나타나는** 방식
  
  - 가중치가 있는 데이터
  
  - 작업 스케줄링
  
  - 네트워크

#### 우선순위 큐를 구현하는 방법

- 배열(Array)
- 연결 리스트
- 힙(Heap)

#### 우선순위 큐 구현 별 시간 복잡도

| 연산종류        | Enqueue(추가) | Dequeue     |
| ----------- | ----------- | ----------- |
| 배열          | O(1)        | O(N)        |
| 정렬된 배열      | O(N)        | O(1)        |
| 연결리스트       | O(1)        | O(N)        |
| 정렬된 연결리스트   | O(N)        | O(1)        |
| **힙(Heap)** | **O(logN)** | **O(logN)** |

#### 힙(Heap)의 특징

- 최대값 또는 최소값을 빠르게 찾아내도록 만들어진 데이터 구조

- 완전 이진 트리의 형태로 **느슨한 정렬 상태를 지속적으로 유지**한다.

- 힙 트리에서는 중복 값을 허용한다

- 데이터가 지속적으로 정렬되어야 하는 경우 사용

- 데이터에 삽입/삭제가 빈번할때 사용

- 파이썬의 heapq

 Minheap(최소 힙)으로 구현되어 있음(가장 작은 값이 먼저 옴)

삽입, 삭제, 수정, 조회 **연산의 속도가 리스트보다 빠르다.**

1) heapq.heapify() 2) heapq.heappop(heap) 3) heapq.heappush(heap, item)

### 셋(set)

- 셋은 수학에서의 ‘집합’을 나타내는 데이터 구조로 python에서는 기본적으로 제공되는 데이터 구조다.

#### 셋의 연산

- .add() **O(1)**

- .remove() **O(1)**

- +(합) **O(N)**

- -(차) **O(N)**

- &(교) **O(N)**

- ^(대칭차집합) **O(N)**

- 데이터의 중복이 없어야 할때사용(고유값들로 이뤄진 데이터가 필요할때)

- 정수가 아닌 데이터의 삽입/삭제/탐색이 번번히 필요할때 사용

#### 2차원 리스트

- 리스트를 원소로 가지는 리스트

```
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

# 이차원 리스트는 행렬(matrix)이다.
matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
]

print(matrix[0][0])
# 1
print(matrix[1][2])
# 6
print(matrix[2][0])
# 7
```

- 특정 값으로 초기화 된 이차원 리스트 만들기

```
matrix = [
  [0, 0, 0],
  [0, 0, 0],
  [0, 0, 0],
  [0, 0, 0]
]
# 100*100 이라면
from pprint import pprint
matrix = []

for _ in range(100):
  matrix.append([0]*100)
pprint(matrix)

# 반복문으로 작성 (n*m 행렬)
n = 4 # 행
m = 3 # 열
for _ in range(n):
  matrix.append([0] * m)

print(matrix)
# [[0, 0, 0], #  [0, 0, 0], #  [0, 0, 0], #  [0, 0, 0]]

# List Comprehension
n = 10 # 행의 개수
m = 10 # 열의 개수

matrix = [[0] * m for _ in range(n)] 
```

- 리스트 컴프리헨션 vs 리스트 곱셈 연산
  
  - 아래의 코드 둘은 결과가 같아보이지만 matrix2는 같은 주소값을 가르키기 때문에 값이 변경되면 전부 똑같이 변경된다. 

```
from pprint import pprint
n = 3
m = 3
# 1
matrix1 = [[0] * m for _ in range(n)]
pprint(matrix1)
# 2
matrix2 = [[0] * m]*n
pprint(matrix2)
```

- M x N 의 2차원 리스트 입력받기

```
# M x N 의 리스트 입력받기 
matrix = []
N, M = map(int, input().split())
for _ in range(N):
    line = list(map(int, input().split()))
    matrix.append(line)
pprint(matrix)

# M x N 의 리스트 입력받기 컴프리헨션
N, M = map(int, input().split())
matrix = [list(map(int, input().split())) for _ in range(N)]
pprint(matrix)
```
