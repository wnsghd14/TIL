1. **정답 : **2****

 

해설 : 수직 분할은 특정 칼럼 단위로 테이블을 분할하여 디스크 I/O(Input/Output)을 줄일 수 있는 방법이다.

| **구분**                                                     | **설명**                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 반정규화의 대상 분석                                         | - 디스크 I/O량이 많아 성능저하 - 경로가 너무 멀어 조인으로 성능저하 - 컬럼을 계산하여 읽을 때 성능 저하 |
| 반정규화 개념                                                | - 시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로 의도적으로 정규화 원칙을 위배하는 행위 |
| - 반정규화를 수행하면 시스템의 성능이 향상되고 관리 효율성을 증가시키지만 데이터의 일관성 및 정합성이 저하될 수 있다. - 과도한 반정규화는 오히려 성능을 저하시킨다. - 반정규화를 위해서는 사전에 데이터의 일관성과 무결성을 우선으로 할지, 데이터베이스의 성능과 단순화를 우선으로 할지를 결정해야 한다. - 반정규화 방법에는 테이블 통합, 테이블 분할, 중복 테이블 추가, 중복 속성 추가 등이 있다. |                                                              |

| **기법분류**        | **기법**                                                     | **내용**                                                     |
| ------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **테이블****병합**  | **1:1 관계**                                                 | 1:1 관계를 통합하여 성능향상                                 |
| **1:M 관계**        | 1:M 관계를 통합하여 성능향상                                 |                                                              |
| **슈퍼/서브타입**   | 슈퍼/서브 관계를 통합하여 성능 향상                          |                                                              |
| **테이블****분할**  | **수직분할**                                                 | 컬럼 단위의 테이블을 디스크 I/O를 분산처리하기 위해 테이블을 1:1로 분리하여 성능향상(트랜잭션의 처리되는 유형파악이 선행되어야 함) |
| **수평분할**        | 행(레코드)단위로 집중 발생되는 트랜잭션을 분석하여 디스크 I/O 및 데이터 접근의 효율성을 높여 성능을 향상하기 위해 행 단위로 테이블을 쪼갬 |                                                              |
| **테이블****추가**  | **중복테이블 추가**                                          | 다른 업무이거나 서버가 다른 경우 동일한 테이블 구조를 중복하여 원격 조인을 제거하고 성능을 향상 |
| **통계테이블 추가** | SUM, AVG 등을 미리 수행하여 계산해 둠으로써 조회 시 성능을 향상 |                                                              |
| **이력테이블 추가** | 이력테이블 중에서 마스터 테이블에 존재하는 레코드를 중복하여 이력 테이블에 존재하는 방법 |                                                              |



![img](https://blog.kakaocdn.net/dn/7cDzz/btrCwhE1KQ1/lUWZCDSQJBEdJAJkj9ksN0/img.png)[도표]수직 분할 by yunamom





2. **정답 : **4****

 

해설 : 

| **구분**        | **설명**                                                     |
| --------------- | ------------------------------------------------------------ |
| **제 1 정규화** | 테이블의 속성 하나는 하나의 속성값만을 가져야 한다.          |
| **제 2 정규화** | 기본키 중에 특정 컬럼에만 종속된 컬럼이 존재할 경우 테이블을 분해한다. |
| **제 3 정규화** | 제 2정규형을 만족하는 상태에서 **이행 함수 종속을 제거**하는 정규화 과정 |

 



3. **정답 : **3****

 

해설 : SINGLE TYPE

항상 같이 조회한다고 했으므로 **하나의 테이블로 통합해서 만드는 SINGLE TYPE 방법**이 가장 올바른 방법이다.

수퍼타입과 서브타입의 변환 시에 가장 고려되어야 하는 것은 애플리케이션이 테이블을 어떻게 사용하는지 이다.

예) 회원번호가 1일때 개인회원, 회원번호가 2일때 법인회원 식으로 구분



![img](https://blog.kakaocdn.net/dn/dPO0LL/btrCIIoiFpf/Uzjg8nKy4c3ZwLA0o68LB1/img.png)by yunamom



**슈퍼/서브타입 데이터 모델의 변환타입 비교**

| **구분**                      | **OneToOne Type**                   | **Plus Type**                                  | **Single Type**                      |
| ----------------------------- | ----------------------------------- | ---------------------------------------------- | ------------------------------------ |
| 특징                          | 개별 테이블 유지                    | 슈퍼+서브타입 테이블                           | 하나의 테이블                        |
| 확장성                        | 우수함                              | 보통                                           | 나쁨                                 |
| 조인성능                      | 나쁨                                | 나쁨                                           | 우수함                               |
| I/O량 성능                    | 좋음                                | 좋음                                           | 나쁨                                 |
| 관리용이성                    | 좋지않음                            | 좋지않음                                       | 좋음(1개)                            |
| 트랜잭션 유형에 따른 선택방법 | 개별 테이블로 접근이 많은 경우 선택 | 슈퍼+서브 형식으로 데이터를 처리하는 경우 선택 | 전체를 일괄적으로 처리하는 경우 선택 |



4. **정답 : **4****

 

해설 : 도메인은 속성이 가질 수 있는 값의 범위이다. (값의 허용범위)

 



5. **정답 : **3****

 

해설 : 제3정규화는 주식별자를 제외한 칼럼 간에 종속성을 확인해서 종속성이 있으면 분할하는 과정이다.

 



6. **정답 : **3****

 

해설 : 교차 엔터티 는 M:N 관계를 해소하기 위해서 인위적으로 만들어진 엔터티이다.

예) 학생, 과목 테이블을 이어주는 수강테이블이 교차 엔터티이다.

#### 엔터티의 종류

| **종류**                                           | **설명**                                                     |
| -------------------------------------------------- | ------------------------------------------------------------ |
| **독립 엔티티** **[Kernel Entity, Master Entity]** | 사람, 물건, 장소 등과 같이 현실세계에 존재하는 엔터티        |
| **업무중심 엔터티** **[Transaction Entity]**       | Transaction이 실행되면서 발생하는 엔터티                     |
| **종속 엔터티** **[Dependent Entity]**             | 주로 1차 정규화로 인해 관련 중심엔티티로부터 분리된 엔터티   |
| **교차 엔티티** **[Intersaction Entity]**          | **M:M의 관계를 해소**하려는 목적으로 만들어진 엔터티 [ex> M:M -> 1:M] |

1. 유형과 무형에 따른 엔터티 종류

   * 유형과 무형으로 구분하는 기준은 물리적 형태의 존재 여부

| **종  류**      | **설  명**                                                   |
| --------------- | ------------------------------------------------------------ |
| **유형 엔터티** | 업무에서 도출되며 지속적으로 사용되는 Entity                 |
| **개념 엔터티** | 개념적으로 사용되는 Entity 유형 엔터티는 물리적 형태가 있지만, 개념 엔터니는 물리적 형태가 없다 |
| **사건 엔터티** | 비즈니스 프로세스를 실행하면서 생성되는 Entity               |

 2. 발생시점에 따른 엔터티 종류

| **종  류**                          | **설  명**                                                   |
| ----------------------------------- | ------------------------------------------------------------ |
| **기본 엔터티** **[Basic Entity]**  | **다른 엔터티로부터 영향을 받지 않고 독립적으로 생성**되는 엔터티 **키 엔터티[Key Entity]**라고도 함 |
| **중심 엔터티** **[Main Entity]**   | 기본 엔터티와 행위 엔터티 간의 중간에 있는 엔터티 기본 엔터티로부터 발생되고 행위 엔터티를 생성하는 엔터티 |
| **행위 엔터티** **[Active Entity]** | **2개 이상의 엔터티로부터 발생**하는 엔터티 지속적으로 정보가 추가되고 변경되는 엔터티 |

 

 



7. **정답 : **2****

 

해설 : 테이블상의 계좌마스터의 기본키가 계좌번호와 고객번호이므로 전체 고객에게 유일한 번호가 할당되는것은 아니다.

즉, 고객별 유일한 계좌번호가 된다. 고객별로 계좌번호가 같을수 있지만 (예: 고객 A, 계좌 123 / 고객 B, 계좌 123)

한 명의 고객의 계좌번호는 유일하다. (예: 고객 A, 계좌 123 / 고객 A, 계좌 124)

 



8. **정답 : **1****

 

해설 : ERD(Entity Relationship Diagram) 작성 절차

가) 엔터티를 그린다.
나) 엔터티를 적절하게 배치한다.
다) 엔터티 간에 관계를 설정한다.
라) 관계명을 기술한다.
마) 관계의 참여도를 기술한다.
바) 관계의 필수 여부를 기술한다.

 



9. **정답 : **2****

 

해설 : 주식별자 → 내부식별자 → 외부식별자

| **식별자 분류**         | **식별자**                                                   | **설명**                                                     |
| ----------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **대표성여부** ** **    | **주식별자**                                                 | - 엔터티 내에서 각 행을 구분할 수 있는 구분자이며, 타 엔터티와 참조관계를 연결할 수 있는 식별자 (ex. 사원번호, 고객번호) |
| **보조식별자**          | - 엔터티 내에서 각 행을 구분할 수 있는 구분자이나 대표성을 가지지 못해 참조관계 연결을 못함(ex. 주민등록번호) |                                                              |
| **스스로** **생성여부** | **내부식별자**                                               | - 엔터티 내부에서 스스로 만들어지는 식별자(ex. 고객번호)     |
| **외부식별자**          | - 타 엔터티와의 관계를 통해 타 엔터티로부터 받아오는 식별자(ex. 주문엔터티의 고객번호) |                                                              |
| **속성의 수**           | **단일식별자**                                               | - 하나의 속성으로 구성된 식별자(ex. 고객엔터티의 고객번호 )  |
| **복합식별자**          | - 둘 이상의 속성으로 구성된 식별자(ex. 주문상세엔터티의 주문번호+상세순번) |                                                              |
| **대체여부**            | **본질식별자**                                               | - 업무(비즈니스)에 의해 만들어지는 식별자(ex. 고객번호)      |
| **인조식별자**          | - 업무적으로 만들어지지는 않지만 원조식별자가 복잡한 구성을 가지고 있기 때문에 인위적으로 만든 식별자(ex. 주문엔터티의 주문번호(고객번호+주문번호+순번)) |                                                              |

 



10. **정답 : **1****


 

해설 : 대체여부에 따라서 본질 식별자와 인조 식별자로 분류되고 → 본질 식별자는 비즈니스 프로세스에 의해서 만들어지는 식별자이다.

 

 



11. **정답 : **1****


 

해설 : RANK() : 중복값은 중복등수, **등수 건너뜀**(1위, 1위, 3위, 4위)

DENSE_RANK() : 중복값은 중복등수, 등수 안 건너뜀(1위, 1위, 2위, 2위)

ROW_NUMBER() : 중복값이 있어도 고유 등수 부여(1위, 2위, 3위, 4위)

 



12. **정답 : **1****


 

해설 : COALESCE 함수는 NULL 값이 아닌 첫번째 값을 반환한다.

COL1 을 기준 ( **100, 3000, 50** )COL1(100)   → **100**COL1(NULL) → COL2(60) * 50 → **3000**COL1(NULL) → COL2 = NULL 이므로→ **50**

 



13. **정답 : **1**** 


 

해설 : CREATE index [인덱스이름] on [테이블이름] (컬럼명);

 



14. **정답 : **4****


 

해설 : UNION ALL → 9개의 행 반환 → MINUS(차집합) → 1, 2, 3, 7, 8 (5개 행)

 



15. **정답 : **2****


 

해설 : Sort Merge 조인은 해당 테이블의 인덱스가 없을때 수행이 된다.

테이블을 정렬(Sort) 한 후에 정렬된 테이블을 병합(Merge) 하면서 조인을 실행한다.



![img](https://blog.kakaocdn.net/dn/cMhAfx/btrCyfNP6hk/fFpE2BdQCNk3w0ZqNkxrz0/img.png)SORT MERGE 조인



 



16. **정답 : **1****


 

해설 : CONNECT BY 는 Oracle 이 지원하는 질의 방법으로 **계층형 구조를 탐색**할 수 있다.

```
SELECT 칼럼, LEVEL AS 계층의 깊이
FROM 테이블
WHERE (조건)
START WITH (시작 위치 조건)
CONNECT BY (PRIOR 하위코드 = 상위코드);
```

| **구분**          | **설명**                                                     |
| ----------------- | ------------------------------------------------------------ |
| CONNECT_BY_ROOT   | 계층형 쿼리에서 최상위 로우를 반환하는 연산자다. 연산자이므로 CONNECT_BY_ROOT 다음에는 표현식이 온다. |
| CONNECT_BY_ISLEAF | CONNECT BY 조건에 정의된 관계에 따라 해당 로우가 최하위 자식 로우이면 1을, 그렇지 않으면 0을 반환하는 의사 컬럼이다. |

**TIP 알아두기***정렬할때 계층형 구조까지 보존하려면 **ORDER SIBLINGS BY** 절을 사용해야 한다.

(같은 부모를 가진 로우, 즉 **레벨이 같은 형제 로우**에 한해서 정렬이 수행됨)

 



17. **정답 : **4****


 

해설 : 순위 함수에 ORDER BY를 사용해서 순위를 기준으로 오름차순 혹은 내림차순으로 출력할 수 있다.

RANK() : 중복값은 중복등수, **등수 건너뜀**(1위, 1위, 3위, 4위)

DENSE_RANK() : 중복값은 중복등수, 등수 안 건너뜀(1위, 1위, 2위, 2위) ***동일 등수 순위에 영향이 없다.**

ROW_NUMBER() : 중복값이 있어도 고유 등수 부여(1위, 2위, 3위, 4위)




18. **정답 : **2****


 

해설 : 제시한 칼럼에 대해서 결합 가능한 모든 집계를 계산한다.

| **구분**         | **설명**                                                     |
| ---------------- | ------------------------------------------------------------ |
| **ROLLUP**       | - 전체합계와 소그룹 간의 소계를 계산하는 ROLLUP 함수  예) GROUP BY ROLLUP (DEPTNO); → DEPTNO 합계(소계), 전체 합계를 조회 |
| **CUBE**         | - CUBE는 제시한 칼럼에 대해서 결합 가능한 모든 집계를 계산한다. - 다차원 집계를 제공하여 다양하게 데이터를 분석할 수 있다.  예) GROUP BY CUBE(DEPTNO, JOB); → DEPTNO 합계, JOB 합계, DEPTNO & JOB 합계, 전체 합계를 조회 **조합할 수 있는 모든 경우의 수가 조합된다. *시스템에 부하를 많이 주는 단점이 있음** |
| **GROUPING SET** | - 원하는 부분의 소계만 손쉽게 추출하여 계산할 수 있는 GROUPING SETS 함수 |

 



19. **정답 : **4****


 

해설 : FULL OUTER JOIN은 총 6개의 행이 조회, LEFT와 RIGHT OUTER JOIN은 총 4개의 행, INNER JOIN은 2개의 행이 조회된다.

 



20. **정답 : **4****


 

해설 : 

(1) 번은 NAME에 DATE 타입의 데이터를 입력하여 에러

(2) 번은 AGE(NOT NULL)에 NULL을 입력하여 에러

(3) 번은 ID(PK) 값을 입력하지 않아서 에러

 



21. **정답 : **4****


 

해설 : ORDER SIBLINGS BY 를 수행하면 전체 테이블이 아니라 계층형으로 된 데이터값(특정 칼럼) 기준으로 정렬된다.

(1) NOT IN (3) 이므로 3이 포함되면 전개를 멈춤

(2) CONNECT BY PRIOR ID = PARENT_ID (부모 ID 를 기준으로 자식 ID 를 검색) 순반향

(3) NO CYCLE 옵션을 사용할 수 있다.

 



22. **정답 : **3****


 

해설 : DESCENDING  (ASC:최소값, DESC:최댓값)

 

UNIQUE SCAN : 유일한 값 하나 찾기 (예: 고객아이디) *한개의 행

RANGE SCAN : 어떠한 조건에서 한 범위를 찾기 (예:주문번호)

FULL SCAN : 전체 데이터 *전체 행

 



23. **정답 : **1****


 

해설 :CASE문을 사용해서 정렬의 순서를 변경했으므로 ID가 13, 10번이 먼저 조회되고 → AGE DESC 이므로 13의 AGE가 가장 먼저 조회된다.

```
sql> SELECT ID, AGE FROM SQLD39_23 ORDER BY (CASE WHEN ID = 10 OR ID = 13 THEN 1 ELSE 2 END),AGE DESC;
+------+------+
| ID   | AGE  |
+------+------+
|   13 |   50 |
|   10 |   20 |
|   14 |   60 |
|   12 |   40 |
|   11 |   30 |
+------+------+
```



24. **정답 : **2****


 

해설 : CHAR는 길이가 서로 다르면 짧은 쪽에 스페이스를 추가하여 같은 값으로 판단한다. 같은 값에서 길이만 서로 다를 경우 다른 값으로 판단하는 것은 VARCHAR(가변길이 문자형 : 입력한 크기만큼 할당 )로 비교하는 경우이다.

 

예) CHAR(5)으로 칼럼을 생성하고 입력값이 3개의 문자일때 'abc' → 'abc  ' 와 같은식으로 나머지 2개는 공백으로 입력된다.

 



25. **정답 : **3****


 

해설 : 주문금액 DESC (결과 테이블은 주문 금액이 큰 순서대로 순위를 부여하는 테이블로 주문금액 속성을 내림차순 정렬했을 때의 순위)

DESC(내림차순)

ASC(올림차순)

 



26. **정답 : **1****


 

해설 : CASE문으로 ID가 1000인 것은 0으로 변경하고 나머지는 ID값으로 ASC(오름차순) 한다. 단, COUNT함수로 2건만 조회된다. (3000, 9999)

 



27. **정답 : **3****


 

해설 : VIEW는 논리적으로 존재하는 가상 테이블로서 물리적으로 실제 데이터를 저장하지 않는다.

 

| **구분**               | **설명**                                                     |
| ---------------------- | ------------------------------------------------------------ |
| *****뷰개념 VIEW**** | 테이블은 실제로 데이터를 가지고 있는 반면, 뷰는 실제 데이터를 가지고 있지 않다. 질의에서 뷰가 사용되면 뷰 정의를 참조해서 DBMS 내부적으로 질의를 재작성하여 질의를 수행 뷰는 실제 데이터를 가지고 있지 않지만 테이블이 수행하는 역할을 수행하기 때문에 가상 테이블이라고도 한다.** ** |
| **독립성**             | 테이블 구조가 변경되어도 뷰를 사용하는 응용 프로그램은 변경하지 않아도 된다. |
| **편리성**             | 복잡한 질의를 뷰로 생성함으로써 관련 질의를 단순하게 작성할 수 있다. |
| **보안성**             | 숨기고 싶은 정보가 존재하는 경우, 뷰를 생성할 때 해당 컬럼을 빼고 생성하여 정보를 숨길 수 있다. |



 

28. **정답 : **1****


 

해설 : GROUP BY구의 기본적인 문법을 확인하는 문제이다. SELECT구에는 GROUP BY절에 있는 칼럼이 나와야 한다.

 



29. **정답 : **3****


 

해설 : 학생과 과목 간의 M:N 관계를 해소하기 위해 수강이라는 교차 엔터티가 사용된다.

| **종류**                                           | **설명**                                                     |
| -------------------------------------------------- | ------------------------------------------------------------ |
| **독립 엔티티** **[Kernel Entity, Master Entity]** | 사람, 물건, 장소 등과 같이 현실세계에 존재하는 엔터티        |
| **업무중심 엔터티** **[Transaction Entity]**       | Transaction이 실행되면서 발생하는 엔터티                     |
| **종속 엔터티** **[Dependent Entity]**             | 주로 1차 정규화로 인해 관련 중심엔티티로부터 분리된 엔터티   |
| **교차 엔티티** **[Intersaction Entity]**          | **M:M의 관계를 해소**하려는 목적으로 만들어진 엔터티 [ex> M:M -> 1:M] |

 



30. **정답 : **3****


 

해설 : 메인쿼리의 값을 서브쿼리에서 주입을 받아서 비교를 하는것으로 상호연관 서브쿼리(CORRELATED SUB QUERY) 이다.

 

SELECT A.EMPNO, A.ENAME
FROM EMP A
WHERE A.EMPNO = (SELECT 1 FROM
EMP_T B WHERE A.EMPNO = B.EMPNO);

서브쿼리에 *(A.EMPNO 값을 매번 가져와서 대입을 해야하므로 **성능이 매우 좋지않다.**)

 



31. **정답 : **2****


 

해설 :

WHERE **COL3** = (SELECT COL3 FROM SQLD39_31_2 WHERE COL2 = 'A') → **10**

**SQLD39_31_1 테이블의 COL3 값이 10인 컬럼은 2개 (DISTINCT COL1) → 1, 3 이므로 중복제거 X **→** 2개**

 



32. **정답 : **4****


 

해설 : VIEW에는 총 4개의 행이 있다.  COL2 가 2000보다 크거나 같은 합계이므로 = 5000

```
[V_SQLD39_32]
COL1   COL2
A      1000
A      2000
NULL   3000
NULL   NULL
```

 



33. **정답 : **2****


 

해설 : 수정(MODIFY)

칼럼의 변경은 ALTER TABLE ~ MODIFY 문을 사용하면 된다. 칼럼은 데이터 타입 및 길이를 변경 할 수 있다.

추가(ADD), 삭제(DROP)

 



34. **정답 : **4****


 

해설 : NULL값은 아직 알려지지 않은 미지의 값이다. (값이 정해지지 않음)

 



35. **정답 : **4****


 

해설 : 특정 하나의 값에 대한 자신의 상위 KPI를 검색하는 것으로, MAINKPI가 0부터 출발하여 WHERE SUBKPI가 30이면(특정 하나의값) 30의 상위 KPI (MAINKPI = 20) 이 같이 출력된다.

**( 프 → 자 → 부 → 순 ) PRIOR, 자식, 부모, 순방향 전개**

**( 프 → 부 → 자 **→ 역** )** PRIOR, 부모, 자식, 역방향 전개

 

```
[RESULT]
SUBKPI  KPINAME  MAINKPI
-------------------------
30      불만건수    20
```

 



36. **정답 : **1****


 

해설 : 문제의 SQL문이 SUBKPI 가 20 이고(AND) MAINKPI가 10 이거나(OR) SUBKPI 가 0 이고(AND) MAINKPI가 30 인 행(20, 10)을 출력 → 정답 1번과 출력값이 같다.

 

```
SELECT * FROM KPIPOOL WHERE
(SUBKPI, MAINKPI) IN ((20,10),(0,30));

SELECT * FROM KPIPOOL WHERE
(SUBKPI = 20 AND MAINKPI = 10) OR
(SUBKPI = 0 AND MAINKPI = 10);

두 쿼리문의 결과는 같다.
*괄호안에 값이 AND OR AND 로 이루어져있음
```

 



37. **정답 : **2****


 

해설 : 서브쿼리에 있는 칼럼을 자유롭게 사용할수 없다 

 



38. **정답 : **2****


 

해설 : 오늘 날짜를 구하기 위해서 SYSDATE+1을 해주면된다. 단, 데이트 타입을 문자열 TO_CHAR 로 변환해주어야 한다.

 



39. **정답 : **2****


 

해설 : FETCH(읽어오기) 위해 해야할 것은 CURSOR OPEN (*CURSOR순서 : 선언 → OPEN → FETCH → CLOSE)

**CURSOR(DB의 연결 포인트, 연결점)**

- SQL 커서는 Oracle 서버에서 할당한 전용 메모리 영역에 대한 포인터이다.
- 질의의 결과로 얻어진 여러 행이 저장된 메모리상의 위치.
- 커서는 SELECT 문의 결과 집합을 처리하는데 사용된다.

명시적 커서란 사용자가 직접 정의해서 사용하는 커서이고 묵시적(암시적) 커서는 데이터베이스가 내부적으로 사용하는 커서이다.

모든 CURSOR는 사용하기 전에 반드시 선언을 해주어야 한다.

```
CURSOR 커서명[(매개변수1, 매개변수2, ...)]
IS
SELECT 문장;

-- CURSOR를 OPEN한다.

OPEN 커서명[(매개변수1, 매개변수2, ...)];

-- FETCH는 실제 테이블에서 데이터를 읽어온다.

LOOP
   FETCH 커서명 INTO 변수1, 변수2, ...
   EXIT WHEN 커서명%NOTFOUND
END LOOP;

-- *사용이 완료된 CURSOR는 반드시 CLOSE 해주어야 한다.

CLOSE 커서명;
```

 



40. **정답 : **2****


 

해설 : C2 칼럼으로 그룹화(1,2) → C2 동일칼럼 수가 2개 이상**(C2 : 1)** → C2가 1인 C3의 총합 **(SUM(C3) : 4 )**

![img](https://blog.kakaocdn.net/dn/l78Pe/btrLhuhyrRs/F5yBsMLSvVLwll2KvIWDk1/img.png)

 



41. **정답 : **2****


 

해설 : 분산 데이터베이스 신뢰성과 가용성이 높다.

| **장점**                                                     | **단점**                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 데이터베이스 신뢰성과 가용성이 높다.                         | 데이터베이스가 여러 네트워크를 통해서 분리되어 있기 때문에 관리와 통제가 어렵다. |
| 분산 데이터베이스가 병렬 처리를 수행하기 때문에 빠른 응답이 가능 | 보안관리가 어렵다.                                           |
| 분산 데이터베이스를 추가하여 시스템 용량 확장이 쉽다.        | 데이터 무결성 관리가 어렵다.                                 |
|                                                              | 데이터베이스 설계가 복잡함                                   |

 



42. **정답 : **3****


 

해설 : **RANDOM ACCESS로 인해 부하가 걸리는 것은 NESTED LOOP JOIN 방식이다.**

| **HASH JOIN**                                                |
| ------------------------------------------------------------ |
| -조인 컬럼의 인덱스가 존재하지 않을 경우에도 사용할 수 있다. |
| -해시 함수를 이용하여 조인을 수행하기 때문에 '='로 수행하는 조인으로 동등 조건에만 사용가능 |
| -해시 함수가 적용될 때 동일한 값을 항상 같은 값으로 해싱됨이 보장된다. |
| -HASH JOIN 작업을 수행하기 위해 해시 테이블을 메모리에 생성해야 한다. |
| -메모리에 적재할 수 있는 영역의 크기보다 커지면 임시 영역(디스크)에 해시 테이블을 저장한다. |
| -HASH JOIN을 할 때는 결과 행의 수가 적은 테이블을 선행 테이블로 사용하는 것이 좋다. |
| -선행 테이블을 Build input이라 하며, 후행 테이블을 Prove input이라 한다. |

 

****- - - - - - - - 주관식 - - - - - - - -****

 



43. **정답 : 3개**


 

해설 : 2차 정규화 → 3차 정규화(종속 존재를 분해) 학번,코스코드(FK),평가코드(FK) = 3개



![img](https://blog.kakaocdn.net/dn/Nsy0G/btrCGVmSOJg/yhQ9so4KEpCsANdYpysKTK/img.png)2차 정규화 by yunamom







![img](https://blog.kakaocdn.net/dn/y22uG/btrCGcJeWF8/rBYVjko0zas5zSyR5meKcK/img.png)3차 정규화 by yunamom



44. **정답 : **7.5, 7.45, 7, 7, 8****


 

해설 : ROUND(반올림) → ROUND(7.45, **1**)이므로 함수의 첫 번째 인자값인 7.45를 **소수점 첫째 자리까지 반올림**

ABS(절댓값) : 예) ABS(-7.45) → 7.45

FLOOR(CEIL의 반대, 정수로 내림)

TRUNC(소수점 버림)

CEIL(정수로 올림)

```
+----------------+-----------+-------------+-------------+------------+
| ROUND(7.45, 1) | ABS(7.45) | FLOOR(7.45) | TRUNC(7.45) | CEIL(7.45) |
+----------------+-----------+-------------+-------------+------------+
|            7.5 |      7.45 |           7 |           7 |          8 |
+----------------+-----------+-------------+-------------+------------+
```

 



45. **정답 : **ROLE****


 

해설 : ROLE은 데이터베이스에서 OBJECT(테이블, 프로시저, 뷰) 등의 권한을 묶어서 관리할 수 있다.

 



46. **정답 : **3****


 

해설 : SQLD39_46 테이블의 N1 (1,2) → 1+2 = 3

 



47. **정답 : **RIGHT OUTER JOIN****


 

해설 : 두 테이블에서 같은 COL1 값을 조회하고 우측 테이블의 값들이 추가로 조회되므로 RIGHT OUTER JOIN

 



48. **정답 : **GRANT, REVOKE****


 

해설 : GRANT(권한부여), REVOKE(권한회수)

 



49. **정답 : **9****


 

해설 : **SQLD 39 회 49 번 해설** !(헷갈리기 쉬운 문제)

SQLD39_42 테이블의 COL1 은 {1, 1, 2, 3, 3} 이렇게 5개가 있습니다.

COL1 을 하나씩 불러오면

문제 WHERE 조건이 A.COL1 = B.COL1 이므로A.COL1 = 1 일때 B.COL1 = 1 인 레코드 → **2개**

A.COL1 = 1 일때 B.COL1 = 1 인 레코드 → **2개**

A.COL1 = 2 일때 B.COL1 = 2 인 레코드 → **1개**

A.COL1 = 3 일때 B.COL1 = 3 인 레코드 → **2개**

A.COL1 = 3 일때 B.COL1 = 3 인 레코드 → **2개**

 

![img](https://blog.kakaocdn.net/dn/urXoh/btr0JN6VQ2Q/kKnK1gbpiI9LHFWgxjKvTK/img.png)

**위와 같은 계산으로 2+2+1+2+2 = 9 가 됩니다.**

 



50. **정답 : **EXISTS****


 

해설 : SQL1 의 결과는 (120, 400) SQL2 에 같은 결과를 반환하기 위해서는 빈칸에 EXISTS를 작성해주어야 합니다.

EXISTS 연산자는 하위 쿼리에 레코드가 있는지 테스트 하는 데 사용됩니다.

하위 쿼리가 하나 이상의 레코드를 반환하는 경우 TRUE 그렇지 않은경우 FALSE

```
SELECT column_name(s)
   FROM table_name
WHERE EXISTS
      (SELECT column_name 
          FROM table_name 
       WHERE condition);
```

반대 연산자는 NOT EXISTS

**EXISTS의 이점은 속도가 빠르다.**

IN 연산자의 경우 서브쿼리의 결과 를 전부 구하고 비교를 시행하지만,

EXISTS는 단 하나라도 결과를 발견하면 즉시 리턴한다.(오로지 존재의 여부만 봄)

레코드가 수십만 개가 넘어가는 테이블의 경우에 EXISTS의 효율을 체감할 수 있음