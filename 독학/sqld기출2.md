\1. **정답 : \**2\****

📖[문제확인](https://yunamom.tistory.com/260#a1)

 

해설 : 반정규화를 하면 데이터 무결성을 해친다.

 

| **구분**                                                     | **설명**                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 반정규화의 대상 분석                                         | - 디스크 I/O량이 많아 성능저하 - 경로가 너무 멀어 조인으로 성능저하 - 컬럼을 계산하여 읽을 때 성능 저하 |
| 반정규화 개념                                                | - 시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로 의도적으로 정규화 원칙을 위배하는 행위 |
| - 반정규화를 수행하면 시스템의 성능이 향상되고 관리 효율성을 증가시키지만 데이터의 일관성 및 정합성이 저하될 수 있다. - 과도한 반정규화는 오히려 성능을 저하시킨다. - 반정규화를 위해서는 사전에 데이터의 일관성과 무결성을 우선으로 할지, 데이터베이스의 성능과 단순화를 우선으로 할지를 결정해야 한다. - 방정규화 방법에는 테이블 통합, 테이블 분할, 중복 테이블 추가, 중복 속성 추가 등이 있다. |                                                              |
| 테이블 통합                                                  | 두 개의 테이블에서 발생하는 프로세스가 동일하게 자주 처리되는 경우, 두 개의 테이블을 이용하여 항상 조회를 수행하는 경우 테이블 통합을 고려한다. |

 



\2. **정답 : \**4\****

📖[문제확인](https://yunamom.tistory.com/260#a2)

 

해설 : 분산데이터베이스는 데이터의 무결성을 완전히 보장하는 것이 불가능하다.

 



\3. **정답 : \**2\****

📖[문제확인](https://yunamom.tistory.com/260#a3)

 

해설 : 

외부 스키마 : 사용자 관점

개념 스키마 : 통합 관점

내부 스키마 : 물리적 관점

 



\4. **정답 : \**4\****

📖[문제확인](https://yunamom.tistory.com/260#a4)

 

해설 : 관계를 표기법은 **관계명**, **관계차수**, **관계선택사양** 세 가지로 이루어져 있다.

 

**관계명(Membership)**

관계명은 엔터티간 관계에 맺어진 형태 뜻한다.

관계가 시작되는 쪽을 "관계시작점(The Beginning)"이라 칭하며 받는쪽을 "관계끝점(The End)"라고 칭한다.

또한 관점에 따라 능동적(Active)이거나 수동적(Passive)으로 명명된다.

 

**관계차수(Degree/Cardinality)**

관계차수란 두 엔터티간 관계에서 수행되는 경우의 수를 뜻한다.



![img](https://blog.kakaocdn.net/dn/rit4V/btrB6tGmtMZ/iMLIeSOP3IpBAQHwjiouEK/img.png)by yunamom



 

**관계선택사양(Optionality)**

관계에서 항상 참여하는지 아니면 참여할 수도 있는지를 나타내는 방법따라 필수참여 관계(Mandatory), 선택참여 관계(Optional)로 나뉜다.

 

고객과 주문 엔터티 관계를 살펴보자. 3명의 손님의 가게에 들어왔다. 하지만 2명의 손님만 주문을 시킬 경우도 있다.

주문은 꼭 손님에 의해서 수행이 되지만, 손님은 주문을 시킬수도 있고 안 시킬수도 있다.

이처럼 주문은 손님에의해 수행이 될수도 있고 안 될수도 있어서 선택참여 관계이고 주문된 항목은 꼭 손님에 의해서 수행이 되어져야 하므로 필수참여 관계이다. 

 

선택참여관계일 경우 ERD에서 관계를 나타내는 선에서 선택참여하는 엔터티쪽에 원을 표시해야한다.

 



\5. **정답 : \**4\****

📖[문제확인](https://yunamom.tistory.com/260#a5)

 

해설 : 

| **분산 데이터베이스** |                                                              |
| --------------------- | ------------------------------------------------------------ |
| **장 점**             | -지역 자치성, 점증적 시스템 용량 확장 -신뢰성과 가용성 -효용성과 융통성 -빠른 응답속도와 통신비용 절감 -데이터의 가용성과 신뢰성 증가 -시스템 규모의 적절한 조절 -각 지역 사용자의 요구 수용 증대 |
| **단 점**             | -소프트웨어 개발 비용 -오류의 잠재성 증대 -처리비용의 증대 -설계, 관리의 복잡성과 비용 -불규칙한 응답 소고 -통제의 어려움 -데이터의 무결성에 대한 위협 |

 



\6. **정답 : \**3\****

📖[문제확인](https://yunamom.tistory.com/260#a6)

 

해설 : '가' 모델의 수강과목 엔터티를 보면 1정규형을 위반한 것이 보인다.

 



\7. **정답 : \**3\****

📖[문제확인](https://yunamom.tistory.com/260#a7)

 

해설 : 테이블 조인 조건 계산( n - 1 )

Student, Grade를 비식별자 관계로 설계하면 Grade, Module은 식별자 관계이므로 Student, Module을 설계 할 때 오히려 조인의 복잡성이 커질 수 있다.

| **식별자 분류**         | **식별자**                                                   | **설명**                                                     |
| ----------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **대표성여부** ** **    | **주식별자**                                                 | - 엔터티 내에서 각 행을 구분할 수 있는 구분자이며, 타 엔터티와 참조관계를 연결할 수 있는 식별자 (ex. 사원번호, 고객번호) |
| **보조식별자**          | - 엔터티 내에서 각 행을 구분할 수 있는 구분자이나 대표성을 가지지 못해 참조관계 연결을 못함(ex. 주민등록번호) |                                                              |
| **스스로** **생성여부** | **내부식별자**                                               | - 엔터티 내부에서 스스로 만들어지는 식별자(ex. 고객번호)     |
| **외부식별자**          | - 타 엔터티와의 관계를 통해 타 엔터티로부터 받아오는 식별자(ex. 주문엔터티의 고객번호) |                                                              |
| **속성의 수**           | **단일식별자**                                               | - 하나의 속성으로 구성된 식별자(ex. 고객엔터티의 고객번호 )  |
| **복합식별자**          | - 둘 이상의 속성으로 구성된 식별자(ex. 주문상세엔터티의 주문번호+상세순번) |                                                              |
| **대체여부**            | **본질식별자**                                               | - 업무에 의해 만들어지는 식별자(ex. 고객번호)                |
| **인조식별자**          | - 업무적으로 만들어지지는 않지만 원조식별자가 복잡한 구성을 가지고 있기 때문에 인위적으로 만든 식별자(ex. 주문엔터티의 주문번호(고객번호+주문번호+순번)) |                                                              |

 



\8. **정답 : \**2\****

📖[문제확인](https://yunamom.tistory.com/260#a8)

 

해설 : 외래키가 설계되어 있지만 인덱스가 없는 상태라면 입력/삭제/수정의 부하가 덜 생긴다.

 



\9. **정답 : \**4\****

📖[문제확인](https://yunamom.tistory.com/260#a9)

 

해설 : ROW의 정보를 검색하기 위해 하나 이상의 데이터 블록을 SCAN해야하기 때문에 성능이 감소될 수 있다.

| **구분**   | **Row Chaining**                                             | **Row Migration**                                            |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **정의**   | 하나의 Row를 하나의 블록에 저장할 수 없어서 여러 블록에 걸쳐서 저장하는 현상 | Update로 인하여 늘어나는 공간을 저장할 공간이 없어서 다른 블록으로 Row를 옮기는 현상 |
| **특성**   | Initial Row Piece(행 조작)와 Row Pointer로 블록 내에 저장됨  | 기존 블록에는 Migration되는 데이터의 row header와 블록 주소값을 갖게 되고, 새로운 블록에는 Migration되는 데이터가 저장됨 |
| **문제점** | Row의 정보를 검색하기 위해 하나 이상의 데이터 블록을 Scan해야 하기 때문에 성능이 감소됨 | Migration된 Row를 읽기 전에 기존 블록에서 헤더를 통해 Migration된 Row를 읽기 때문에 성능이 감소됨 |
| **해결책** | 블록의 크기를 크게 만든다.                                   | -PCTFREE를 크게 설정-객체를 Export하고 삭제한 후 import-객체를 Migration하고Truncate |

 



\10. **정답 : \**4\****

📖[문제확인](https://yunamom.tistory.com/260#a10)

 

해설 : 통계 테이블 추가는 테이블 추가에 해당한다.

| **기법분류**                  | **기법**                                                     | **내용**                                                     |
| ----------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **테이블****병합**            | **1:1 관계 테이블 병합**                                     | 1:1 관계를 통합하여 성능향상                                 |
| **1:M 관계 테이블 병합**      | 1:M 관계를 통합하여 성능향상                                 |                                                              |
| **슈퍼/서브타입 테이블 병합** | 슈퍼/서브 관계를 통합하여 성능 향상                          |                                                              |
| **테이블****분할**            | **수직분할**                                                 | 컬럼 단위의 테이블을 디스크 I/O를 분산처리하기 위해 테이블을 1:1로 분리하여 성능향상(트랜잭션의 처리되는 유형파악이 선행되어야 함) |
| **수평분할**                  | 행(레코드)단위로 집중 발생되는 트랜잭션을 분석하여 디스크 I/O 및 데이터 접근의 효율성을 높여 성능을 향상하기 위해 행 단위로 테이블을 쪼갬 |                                                              |
| **테이블****추가**            | **중복테이블 추가**                                          | 다른 업무이거나 서버가 다른 경우 동일한 테이블 구조를 중복하여 원격 조인을 제거하고 성능을 향상 |
| **통계테이블 추가**           | SUM, AVG 등을 미리 수행하여 계산해 둠으로써 조회 시 성능을 향상 |                                                              |
| **이력테이블 추가**           | 이력테이블 중에서 마스터 테이블에 존재하는 레코드를 중복하여 이력 테이블에 존재하는 방법 |                                                              |

 



\11. **정답 : \**2\****

📖[문제확인](https://yunamom.tistory.com/260#a11)

 

해설 : NATURAL JOIN에서 EMP.DEPTNO와 같이 OWNER 명을 사용하면 에러 발생

 



\12. **정답 : \**4\****

📖[문제확인](https://yunamom.tistory.com/260#a12)

 

해설 : 1,2,3번은 2개의 테이블에서 동일한 이름을 가지는 칼럼에 대해서 조인을 수행하는 방식이고 4번은 두 테이블의 모든 데이터에 대해서 조인을 수행하는 CROSS JOIN 방식임.

 



\13. **정답 : \**1\**** 

📖[문제확인](https://yunamom.tistory.com/260#a13)

 

해설 : UNION은 중복된 행을 제거하고 정렬한다. UNION ALL은 합집합

 



\14. **정답 : \**1\****

📖[문제확인](https://yunamom.tistory.com/260#a14)

 

해설 : 1번은 200<= A <=400, 200<= B <=400의 의미이고 나머지는 모두 COL1<=200 && COL2>=200를 의미함

 



\15. **정답 : \**3\****

📖[문제확인](https://yunamom.tistory.com/260#a15)

 

해설 : ACID

Atomicity(원자성)

Consistency(일관성)

Isolation(고립성)

Durability(영속성)

 



\16. **정답 : \**4\****

📖[문제확인](https://yunamom.tistory.com/260#a16)

 

해설 : COMMIT이 완료되지 않은 데이터를 다른 사용자가 고칠 수 없다.(고립성)

 



\17. **정답 : \**3\****

📖[문제확인](https://yunamom.tistory.com/260#a17)

 

해설 : NULL은 오로지 IS NULL, IS NOT NULL로만 조회가 가능




\18. **정답 : \**3\****

📖[문제확인](https://yunamom.tistory.com/260#a18)

 

해설 : LIKE 연산으로 %나 _가 들어간 문자를 검색하기 위해서는 ESCAPE 명령어를 사용할 수 있다. 사용 방법은 _나 % 앞에 ESCAPE로 특수 문자를 지정하면 검색할 수 있다.

 



\19. **정답 : \**2\****

📖[문제확인](https://yunamom.tistory.com/260#a19)

 

해설 : ROWNUM = 1은 사용 가능 하지만 ROWNUM = 2인 경우는 데이터가

추출되지 않는다.

(ROWNUM은 WHERE절을 만족하는 레코드에 붙이는 순번이므로 해석해 보면,

ROWNUM = 2는, 처음 한 건 추출해서 ROWNUM이 2인지 비교하는 것이다.

하지만 처음 레코드는 ROWNUM이 1이며, 조건에 맞지 않다.

 



\20. **정답 : \**3\****

📖[문제확인](https://yunamom.tistory.com/260#a20)

 

해설 :

금액1 : **300** -> NVL(=ISNULL) A가 NULL이면 B로 가고, 아니면 A를 출력

금액2 : **300** -> COALESCE NULL이 아닌 최초값 출력

금액3 : **NULL** -> NULLIF A와 B의 값이 같으면 NULL, 아니면 A를 출력

금액4 : **300** -> CASE WHEN A IS NOT NULL THEN A ELSE B END : A가 NOT NULL이면 A 출력, 아니면 B 출력

 



\21. **정답 : \**3\****

📖[문제확인](https://yunamom.tistory.com/260#a21)

 

해설 : SQL server (EXCEPT) / Oracle (MINUS)

 



\22. **정답 : \**4\****

📖[문제확인](https://yunamom.tistory.com/260#a22)

 

해설 : 

UNBOUNDED PRECEDING은 end point에서 사용될 수 없다.

RANGE BETWEEN start_point AND end_point

-start point는 end_point와 같거나 작은 값이 들어간다.

-Default값은 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW가 된다.

-UNBOUNDED PRECEDING : start_point만 들어갈 수 있으며 파티션의 first row가 된다.

-UNBOUNDED FOLLOWING : end_point만 들어갈 수 있으며 파티션의 last_row가 된다.

-CURRENT ROW : start_point, end_point 둘 다 가능하다. 윈도우는 CURRENT ROW에서 start하거나 end한다.

 



\23. **정답 : \**4\****

📖[문제확인](https://yunamom.tistory.com/260#a23)

 

해설 :인덱스 중 B-트리 인덱스는 Equal 조건뿐 아니라 BETWEEN, > 과 같은 연산자로 검색하는 범위 검색에도 사용될 수 있다.

| **인덱스의 특징**                                            |
| ------------------------------------------------------------ |
| **- 인덱스는 원하는 데이터를 쉽게 찾을 수 있도록 돕는 책의 색인과 유사한 개념이다.** |
| **- 인덱스는 테이블을 기반으로 선택적으로 생성할 수 있는 구조이다.** |
| **- 인덱스의 기본적인 목적은 검색 성능의 최적화이다.**       |
| **- 검색 조건을 만족하는 데이터를 인덱스를 통해 효과적으로 찾을 수 있도록 돕는다.** |
| **- DML작업은 테이블과 인덱스를 함께 변경하므로 느려지는 단점이 존재한다.** |
| **- 인덱스 데이터는 인덱스를 구성하는 칼럼의 값으로 정렬을 수행한다.** |

 



\24. **정답 : \**1\****

📖[문제확인](https://yunamom.tistory.com/260#a24)

 

해설 : 

| **서브쿼리**                    | **설명**                                                     |
| ------------------------------- | ------------------------------------------------------------ |
| **SELECT**  **스칼라 서브쿼리** | 스칼라 서브쿼리는 한 행, 한 컬럼만을 반환하는 서브쿼리를 말합니다. |
| **FROM** **인라인 \*뷰**        | 서브쿼리가 FROM 절에 사용되면 동적으로 생성된 테이블인 것처럼 사용할 수 있습니다. 인라인 뷰는 SQL 문이 실행될 때만 임시적으로 생성되는 동적인 뷰이기 때문에 데이터베이스에 해당 정보가 저장되지 않습니다. |
| **WHERE / HAVING 서브쿼리**     | 그룹함수와 함께 사용될 때 그룹핑된 결과에 대해 부가적인 조건을 주기 위해 사용합니다. |

| **구분**                | **설명**                                                     |
| ----------------------- | ------------------------------------------------------------ |
| ***\**뷰 개념 VIEW\**** | 테이블은 실제로 데이터를 가지고 있는 반면, 뷰는 실제 데이터를 가지고 있지 않다. 질의에서 뷰가 사용되면 뷰 정의를 참조해서 DBMS 내부적으로 질의를 재작성하여 질의를 수행 뷰는 실제 데이터를 가지고 있지 않지만 테이블이 수행하는 역할을 수행하기 때문에 가상 테이블이라고도 한다.** ** |
| **독립성**              | 테이블 구조가 변경되어도 뷰를 사용하는 응용 프로그램은 변경하지 않아도 된다. |
| **편리성**              | 복잡한 질의를 뷰로 생성함으로써 관련 질의를 단순하게 작성할 수 있다. |
| **보안성**              | 숨기고 싶은 정보가 존재하는 경우, 뷰를 생성할 때 해당 컬럼을 빼고 생성하여 정보를 숨길 수 있다. |

 



\25. **정답 : \**4\****

📖[문제확인](https://yunamom.tistory.com/260#a25)

 

해설 : 예외처리는 필수가 아니다.

 



\26. **정답 : \**3\****

📖[문제확인](https://yunamom.tistory.com/260#a26)

 

해설 : Lock/Unlock은 병행성 제어(동시성) 기법이다.

무결성 : 데이터 임의 갱신으로부터 보호해야 하는 것.

제약조건을 넣어서 무결성을 보장하거나, Triger 로직 안에 검사 기능을 넣을 수도 있고, 개발자의 코딩에서 로직을 넣을 수도 있다.

 



\27. **정답 : \**3\****

📖[문제확인](https://yunamom.tistory.com/260#a27)

 

해설 : MANAGER_ID IS NULL 로 시작했기 때문에 부모에서 자식으로 조회하는 정방향이다.

 



\28. **정답 : \**2\****

📖[문제확인](https://yunamom.tistory.com/260#a28)

 

해설 : _ (한글자), A%(A로 시작하는), %A(A로 끝나는)

 



\29. **정답 : \**2\****

📖[문제확인](https://yunamom.tistory.com/260#a29)

 

해설 : CLERK행 + K로 시작하는 연봉 3000이상 반환

 



\30. **정답 : \**2\****

📖[문제확인](https://yunamom.tistory.com/260#a30)

 

해설 : CHAR(10)으로 칼럼을 생성하고 8개의 문자를 입력하면 나머지 2개는 공백으로 입력된다. VARCHAR2는 가변길이 문자열 타입으로 입력한 크기만큼 할당된다.

 



\31. **정답 : \**2\****

📖[문제확인](https://yunamom.tistory.com/260#a31)

 

해설 : 2번만 5를 반환하고 나머지는 '05'를 반환

SUBSTR 문자열 슬라이싱 -> '20190504'의 5번째 '0'에서 2번째까지 -> '05'

EXTRACT (YEAR/MONTH/DAY FROM SYSDATE) 연,월,일을 뽑아서 출력 -> 5(문자열 아님)

CONCAT 문자열 결합 -> '05'

TRIM 공백 제거 -> '05'

 



\32. **정답 : \**2\****

📖[문제확인](https://yunamom.tistory.com/260#a32)

 

해설 : 

UPPER 대문자로 변환 -> 'EBAC'

RTRIM 오른쪽 공백 제거 -> ' EBAC'

SUBSTR 문자열 슬라이싱 -> 'ABCEBACED'의 4번째 'EBACED'에서 4번째까지 -> 'EBAC'

CONCAT 문자열 결합 -> 'EBAC'

 



\33. **정답 : \**4\****

📖[문제확인](https://yunamom.tistory.com/260#a33)

 

해설 : 뒤에서 4번째 자리값인 6부터 2개 반환 -> 67 

 



\34. **정답 : \**1\****

📖[문제확인](https://yunamom.tistory.com/260#a34)

 

해설 :

**단일행 서브쿼리**

-서브쿼리의 실행 결과가 항상 1건 이하인 서브쿼리

-항상 비교연산자와 함께 사용된다.

-비교연산자 뒤에는 단일행이 와야 하는데 뒤에 GROUP BY DEPT는 다중행 함수로 멀티행을 반환하여 에러가 발생함.

**다중행 서브쿼리**

-서브쿼리의 실행 결과가 여러 건인 서브쿼리

-메인 쿼리의 조건 절에 여러 칼럼을 동시에 비교할 수 있다.

-서브쿼리와 메인쿼리의 칼럼 수와 칼럼 순서가 동일해야 한다.

 



\35. **정답 : \**2\****

📖[문제확인](https://yunamom.tistory.com/260#a35)

 

해설 : 연산자 우선순위에 따라 몸무게 65인 모든 사람을 뽑고 A OR B인 팀도 뽑음

 



\36. **정답 : \**3\****

📖[문제확인](https://yunamom.tistory.com/260#a36)

 

해설 : 고유키로 지정된 모든 칼럼은 중복된 값을 허용하진 않지만 NULL값은 가질 수 있다.

 



\37. **정답 : \**2\****

📖[문제확인](https://yunamom.tistory.com/260#a37)

 

해설 : 다중행 입력 쿼리문으로 Case문과 동일하게 수행되며 WHEN을 만족하면 종료한다.

그래서 T1행에는 2, 3 T2행에는 NULL, T3행에는 1이 입력된다.

 



\38. **정답 : \**1\****

📖[문제확인](https://yunamom.tistory.com/260#a38)

 

해설 : STRING_SPLIT : 조회된 skills 컬럼의 쉼표(',') 구분자를 잘라서 해당 개수만큼 행으로 변환한다.

FROM절에서 해당 함수를 사용할 수 있다.

 



\39. **정답 : \**3\****

📖[문제확인](https://yunamom.tistory.com/260#a39)

 

해설 : FROM절에서 DISTINCT 명령어로 중복된 COL1, COL2값은 제외되어 COL1, COL2가 (1, A), (1,B)인 2개의 행만 반환되고 각각 COUNT값 2를 반환한다.

 



\40. **정답 : \**3\****

📖[문제확인](https://yunamom.tistory.com/260#a40)

 

해설 : **a 기준 집계 두번 한 결과**

 

"롤업을 하면 총계가 나온다"
롤업은 괄호 안의 항목들을 오른쪽부터 하나씩 지워나가면서 집계한다.


예를 들면 ROLLUP(a, b) 는
\1. (a, b) 합계
\2. (a) 합계
\3. () 합계
이렇게 3가지 형태의 집계 결과가 나오게 된다.

ROLLUP(a), a 를 보면
\1. (a), a
\2. (), a
이렇게 두가지 형태의 집계 결과가 나오게 된다.


a 가 두번 나오나 한번 나오나 다 같은 a 기준 집계 **결론은 a 기준 집계 두번 한 결과**

 

 



\41. **정답 : \**1\****

📖[문제확인](https://yunamom.tistory.com/260#a41)

 

해설 : 

| **연산자**            | **연산자의 의미**                                            |
| --------------------- | ------------------------------------------------------------ |
| **BETWEEN a AND b**   | a와 b의 값 사이에 있으면 된다. (a와 b의 값이 포함됨) :a<=COL<=B |
| **IN(list)**          | 리스트에 있는 값 중에서 어느 하나라도 일치하면 된다.         |
| **LIKE '비교문자열'** | 비교문자열과 형태가 일치하면 된다.                           |
| **IS NULL**           | NULL 값인 경우                                               |

 



\42. **정답 : \**2\****

📖[문제확인](https://yunamom.tistory.com/260#a42)

 

해설 : LEFT OUTER JOIN 이므로 SQLD_42_1 컬럼의 데이터가 다 출력되어야 한다.

 

 

***\*- - - - - - - - 주관식 - - - - - - - -\****

 



\43. **정답 : RANK(), ROW_NUMBER()**

📖[문제확인](https://yunamom.tistory.com/260#a43)

 

해설 : 그룹 내 순위함수

RANK() : 중복값은 중복등수, 등수 건너뜀(1위, 1위, 3위, 4위)

DENSE_RANK() : 중복값은 중복등수, 등수 안 건너뜀(1위, 1위, 2위, 2위)

ROW_NUMBER() : 중복값이 있어도 고유 등수 부여(1위, 2위, 3위, 4위)

 



\44. **정답 : \**3.5\****

📖[문제확인](https://yunamom.tistory.com/260#a44)

 

해설 : ROUND 함수의 첫 번째 인자값인 3.45를 소수점 첫째 자리까지 반올림

 



\45. **정답 : \**HASH JOIN\****

📖[문제확인](https://yunamom.tistory.com/260#a45)

 

해설 :

| **HASH JOIN 이란?**                                          |
| ------------------------------------------------------------ |
| -조인 컬럼의 인덱스가 존재하지 않을 경우에도 사용할 수 있다. |
| -해시 함수를 이용하여 조인을 수행하기 때문에 '='로 수행하는 조인으로 동등 조건에만 사용가능 |
| -해시 함수가 적용될 때 동일한 값을 항상 같은 값으로 해싱됨이 보장된다. |
| -HASH JOIN 작업을 수행하기 위해 해시 테이블을 메모리에 생성해야 한다. |
| -메모리에 적재할 수 있는 영역의 크기보다 커지면 임시 영역(디스크)에 해시 테이블을 저장한다. |
| -HASH JOIN을 할 때는 결과 행의 수가 적은 테이블을 선행 테이블로 사용하는 것이 좋다. |
| -선행 테이블을 Build input이라 하며, 후행 테이블을 Prove input이라 한다. |

 



\46. **정답 : \**상품명, ()\****

📖[문제확인](https://yunamom.tistory.com/260#a46)

 

해설 : 

 



\47. **정답 : \**UPDATE\****

📖[문제확인](https://yunamom.tistory.com/260#a47)

 

해설 : UPDATE ~ SET ( 수정 )

INSERT INTO (입력)

DELETE (삭제)

 



\48. **정답 : \**ROLLBACK\****

📖[문제확인](https://yunamom.tistory.com/260#a48)

 

해설 : 복구명령어 

 



\49. **정답 : \**EMPLOYEE_ID, DEPARTMENT_ID, salary\****

📖[문제확인](https://yunamom.tistory.com/260#a49)

 

해설 :* 별칭이 없는 칼럼은 대문자로 바뀌고, 별칭이 있는 칼럼은 그대로 사용

(SQL Server의 경우는 별칭이 없는 칼럼도 그대로 사용)

 



\50. **정답 : \**4\****

📖[문제확인](https://yunamom.tistory.com/260#a50)

 

해설 : 위 테이블에서 계층형 쿼리 결과로 총 5건(1,3,7,4,8)이 조회되면 여기서 WHERE 조건절인 COL1<>인 4번째 행이 제외되어 총 4건이 나온다.