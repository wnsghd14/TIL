1. 객체지향프로그래밍이란 ?

   1. 객체 지향 프로그래밍은 컴퓨터 프로그래밍 패러다임 중 하나로, 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법입니다.

   2. \- **장점**

      ▶코드 재사용이 용이

      남이 만든 클래스를 가져와서 이용할 수 있고 상속을 통해 확장해서 사용할 수 있다.

      ▶유지보수가 쉬움

      절차 지향 프로그래밍에서는 코드를 수정해야할 때 일일이 찾아 수정해야하는 반면 객체 지향 프로그래밍에서는 수정해야 할 부분이 클래스 내부에 멤버 변수혹은 메서드로 존재하기 때문에 해당 부분만 수정하면 된다. 

      ▶대형 프로젝트에 적합

      클래스 단위로 모듈화시켜서 개발할 수 있으므로 대형 프로젝트처럼 여러 명, 여러 회사에서 프로젝트를 개발할 때 업무 분담하기 쉽다.

      \- **단점**

      ▶처리 속도가 상대적으로 느림

      ▶객체가 많으면 용량이 커질 수 있음

      ▶설계시 많은 시간과 노력이 필요

   3. 클래스란? 

      1. 어떤 문제를 해결하기 위한 데이터를 만들기 위해 추상화를 거쳐 집단에 속하는 **속성**(attribute)과 **행위**(behavior)를 **변수**와 **메서드**로 정의한 것으로 객체를 만들기 위한 메타정보라고 볼 수 있다.

   4. 인스턴스란?

      1. 객체라고 부르며 클래스에서 정의한 것을 토대로 실제 메모리에 할당된 것으로 실제 프로그램에서 사용되는 데이터

2. REST_API 란?

   1. REST_API란 웹상에서 사용되는 여러 리소스를 HTTP URI로 표현하고, 해당리소스에 대한 행위를 HTTP Method로 정의하는 방식을 말합니다.
   2.  rest full 규약을 지켜 개발하는 것 대표적으로 self-descriptive 와 hateos등이 있습니다. 
      1. rest-api 설계를 할때 url에 동사를 사용하지 않고 명사를 사용하는 등에 rest api 디자인 가이드가 있습니다.

3. HTTP_METHOD
   1. GET: 서버로 부터 데이터를 취득
   2. POST: 서버의 데이터를 추가, 작성 등
   3. PUT: 서버의 데이터를 갱신, 작성 등
   4. DELETE: 서버의 데이터를 삭제
   5. HEAD: 서버 리소스의 헤더(메타 데이터의 취득)
   6. OPTIONS: 리소스가 지원하고 있는 메소드의 취득
   7. PATCH: 리소스의 일부분을 수정
   8. CONNECT: 프록시 동작의 터널 접속을 변경
   9. 비교질문
      1. HTTP METHOD에는 get, post, put, delete 가 있습니다.
         get은 클라이언트에서 서버로 어떠한 리소스로부터 정보를 요청하기 위해 사용되는 method입니다. 즉, 서버에서 어떤 데이터를 가져와서 보여줄 때, 값이나 내용, 상태 등을 바꾸지 않는 경우에 사용합니다.
         post는 리소스를 생성/ 업데이트하기 위해 서버에 데이터를 보내는 데 사용되는 method입니다. 서버상의 데이터 값이나 상태를 바꾸기 위해서 사용합니다.
         주요 차이점으로는, get 요청은 캐시가 되나, post는 캐시 되지 않습니다. get은 브라우저에 기록되지만 post는 기록되지 않습니다.
      2. PUT vs PATCH
         1. PUT은 전체 PATCH는 일부데이터
      3. JsonPatch vs JsonMergePatch
         1. JsonPatch
            1. JsonPatch 방식은 커맨드  방식으로 동작
            2. op, path, value 3개의 항목으로 구성되어 있으며 각 항목을 사용
            3. op : 작업유형 (add, remove, replace, move, copy or test 중에 하나만 사용가능)
            4. path : 변경할 데이터 경로
            5. value: 변경할 값
            6. contect-type : application/json-patch+json
         2. JsonMergePatch
            1. JsonMergePatch
               1. JsonMergePatch는 JsonPatch보단 간단하고 단순하다.
               2. 변경하려는 데이터를 json형식으로 작성하여 던지면 해당되는 데이터들이 merge되는 방식
               3. 키를 null로 변경하는것은 삭제를 의미
               4. content-type : application/merge-patch+json
      4. HTTP 상태 코드에 대해 아는 대로 말해보세요.
         1. 200 : OK, 요청이 성공적으로 되었습니다. 정보는 요청에 따른 응답을 반환됩니다.
         2. 404: 서버는 요청받은 리소스를 찾을 수 없습니다. 브라우저에서는 알려지지 않은 URL을 의미합니다. APL에서 종점은 적절하지만 리소스 자체는 존재하지 않음을 의미할 수 있습니다. 서버들은 인증받지 않은 클라이언트로부터 리소스를 숨기기 위하여 이 응답을 403 대신에 전송할 수도 있습니다.
         3. 503 : 서버가 요청을 처리할 준비가 되지 않았습니다. 유지 보수를 위해 작동이 중단되거나 과부하가 걸린 서버일 경우 발생합니다.
         4. 1xx (정보) : 요청받았으며, 프로세스가 계속 진행합니다.
         5. 2xx (성공) : 요청을 성공적으로 받았으며 인식했고 수용합니다.
         6. 3xx (리다이렉션) : 요청 완료를 위해 추가 작업 조치가 필요합니다.
         7. 4xx (클라이언트 오류) : 요청의 문법이 잘못되었거나 요청을 처리할 수 없습니다.
         8. 5xx (서버 오류) : 서버가 명백히 유효한 요청에 대해 충족을 실패했습니다.

4. API 개발을 하면서 주의하는거나 신경쓰는 부분은?
   1. self-descriptive, hateos, rest api 디자인 가이드 찾아보고 이야기.

5. HTTP_status_code
   1. 1xx(정보) : 요청을 받았으며 프로세스를 계속 진행합니다.
   2. 2xx(성공) : 요청을 성공적으로 받았으며, 인식했고 수용하였다.
      1. 200 OK : 요청이 성공적으로 되었다.
      2. 201 Created : 요청이 성공적이었으며 그 결과로 새로운 리소스가 생성되었다.
   3. 3xx(리다이렉션) : 요청완료를 위해 추가 작업 조치가 필요하다.
   4. 4xx(클라이언트 오류) : 요청의 문법이 잘못되었거나 요청을 처리할 수 없다.
      1. 400 Bad Request : 이 응답은 잘못된 문법으로 인해 서버가 요청하여 이해할 수 없음
      2. 403 Forbidden : 클라이언트는 콘텐츠에 접근할 권리를 가지고 있지 않다.
   5. 5xx(서버 오류) : 서버가 명백히 유효한 요청에 대한 충족을 실패했다.

6. HTTP의 약점
   1. 평문(암호화 하지 않은)통신이기 때문에 도청가능
   2. 통신 상대를 확인하지 않기 때문에 위장 가능
   3. 완전성을 증명할 수 없기 때문에 변조가능

7. HTTPS
   1. SSL(secure Socket Layer) 프로토콜과 http 프로토콜의 조합을 통해 http 통신내용을 암호화
   2. http 통신 내용을 암호화 하기 위해 사용

8. SSL계층
   1. 인터넷 상에서 데이터를 안전하게 전송하기 위한 인터넷 암호화 통신 프로토콜
   2. ssl은 보안계층으로 응용 계층과 전송 계층 사이에 속합니다.

9. 웹/시스템 개발자로 지원하기 위해 어떤 공부를 하셨나요?

   - 웹 개발자로 지원하기 위해 저는 우선 멀티캠퍼스 주관 k디지털트레이닝 교육을 들었고, 해당 과정에서 python, sql, html, css, javascript, django, bootstrap, aws, postgresql, sqlite3 등의 웹 언어와 프레임워크, db 등을 배웠습니다. 그 이후로 DRF관련 공부를 진행중에 있으며, api에 대한 공부를 하고 있습니다.

10. 혹시 저희 회사에 대해 들어보셨나요 ?

11. heap 영역과 stack 영역에 대해 설명?

12. heap 영역과 stack 영역

    - 코드(code) 영역

      메모리의 코드(code) 영역은 실행할 프로그램의 코드가 저장되는 영역으로 텍스트(code) 영역이라고도 부릅니다.

      CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리하게 됩니다.

    - 데이터(data) 영역

      메모리의 데이터(data) 영역은 프로그램의 전역 변수와 정적(static) 변수가 저장되는 영역입니다.

      데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸합니다.

    - 스택(stack) 영역

      메모리의 스택(stack) 영역은 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역입니다.

      스택 영역은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸합니다.

      이렇게 스택 영역에 저장되는 함수의 호출 정보를 스택 프레임(stack frame)이라고 합니다.

      스택 영역은 푸시(push) 동작으로 데이터를 저장하고, 팝(pop) 동작으로 데이터를 인출합니다.

      이러한 스택은 후입선출(LIFO, Last-In First-Out) 방식에 따라 동작하므로, 가장 늦게 저장된 데이터가 가장 먼저 인출됩니다.

      스택 영역은 메모리의 높은 주소에서 낮은 주소의 방향으로 할당됩니다.

    - 힙(heap) 영역

      메모리의 힙(heap) 영역은 사용자가 직접 관리할 수 있는 ‘그리고 해야만 하는’ 메모리 영역입니다.

      힙 영역은 사용자에 의해 메모리 공간이 동적으로 할당되고 해제됩니다.

      힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당됩니다.

13. 스택과 힙의 장단점

    - 스택

      매우 빠른 액세스

      변수를 명시 적으로 할당 해제 할 필요가 없습니다.

      공간은 CPU에 의해 효율적으로 관리되고 메모리는 단편화되지 않습니다.

      지역 변수 만

      스택 크기 제한 (OS에 따라 다름)

      변수의 크기를 조정할 수 없습니다.

    - 힙

      변수는 전역 적으로 액세스 할 수 있습니다.

      메모리 크기 제한 없음

      (상대적으로) 느린 액세스

      효율적인 공간 사용을 보장하지 못하면 메모리 블록이 할당 된 후 시간이 지남에 따라 메모리가 조각화되어 해제 될 수 있습니다.

      메모리를 관리해야합니다 (변수를 할당하고 해제하는 책임이 있습니다)

14. 자기소개!

    - 안녕하십니까 이번에 백엔드 개발자로 지원하게된 최준홍이라고 합니다. 저는 많은 분야에 도전을 해오다 번번히 실패 이후 마지막이다 라는 마음으로 코딩을 배우기 시작, 현재 개발에 푹 빠져 개발자의 꿈을 꾸고 있습니다. 저는 멀티캠퍼스 주관 파이썬을 활용한 풀스택웹개발자 취업캠프라는 교육을 수료하였으며 스스로 게시판 및 간단한 웹사이트 정도는 프론트 백 구분없이 모두 구현가능하고, aws도 간단한 정도는 다룰줄 압니다. 저는 굉장히 평범한 사람입니다. 대화에 있어 주도적이어야 할땐 주도적이고, 경청해야 할땐 경청하는 편이며 이는 업무에서도 마찬가지입니다. 저는 이러한 것이 저의 장점이라고 생각합니다. 물론 단점도 있습니다. 그것은 성실성입니다. 하지만 이를 극복하려 아주 많은 노력을 해왔고, 현재는 예전에 비해 많이 부지런해지게 되어 하루공부시간을 꾸준히 유지하고, 아르바이트를 하며 생활비도 충당하는 등 단점을 이겨내려 많은 노력중에 있습니다. 저는 저학력자입니다. 대학을 갈 수있었지만 다른 뜻을 품게 되어 도전을 하였고 번번히 실패하여 여기까지 돌아왔습니다. 그렇기 때문에 학력은 저에게 가장 큰 컴플렉스 입니다. 하지만 이를 해결하기 위해 현재 학점은행제 강의를 듣고 있으며 컴퓨터 공학학사를 1년내에 취득할것입니다. 이렇듯 저는 후회를 많이 남기지만 언제나 그 후회를 되돌아보며 다시는 되풀이 하지 않기 위해 최선을 다하여 문제를 해결하고자 노력하는 사람입니다. 여기까지가 저의 자기소개 입니다. 감사합니다.

15. 어떤 웹 언어에 익숙하신가요?

    - 아무래도 파이썬 입니다. 파이썬으로 백준 알고리즘 골드5레벨에 도달했고, 그 이외에도 장고를 활용할때도 파이썬을 사용했기 때문에 가장 익숙한 언어입니다. 아직 모든 영역에 익숙하고 능숙하다고 자신할수는 없으나 꾸준히 공부를 하고 있기 때문에 저에겐 가장 익숙한 언어입니다.

16. 장고와 파이썬에 익숙하신가요?

    - 미니프로젝트 포함 약 10가지 정도의 프로젝트를 만들어 본적이 있습니다. 익숙한 편이라고 말씀드릴 수 있습니다.

17. 웹/앱 개선에 어떤 경험이 있나요?

    - 우선 첫번째로 게시글의 간단한 신고기능 (리스트에 사용자의 이름을 집어넣어 그 길이를 측정하는 알고리즘 활용)에서 중복 아이디를 없애기 위해 list가 아닌 set을 사용하게 만든 점, 그리고 한 프로젝트에선 팀장을 맡아 많은 부분의 프론트엔드 문제점 및 백엔드 문제점 등을 피드백하고 함께 고쳐나간 등의 경험이 있습니다.

18. 자신의 가장 큰 강점은 무엇이라고 생각하나요?

    - 저는 아주 평범한 사람입니다. 그렇기 때문에 어느 누구나 될 수있습니다. 팀에서 팀원이 필요하면 책임감을 가진 팀원이 될 수 있으며, 팀장이 필요하면 모두를 잘 이끄려 노력하는 팀장이 될 수도 있습니다. 이러한 점이 저의 가장 큰 장점이라고 생각합니다.

19. 어려운 상황에 어떻게 대처하나요?

    - 저는 위기상황일수록 강해진다고 생각합니다. 예시로 호주워킹홀리데이 시절 외국을 처음 나가봤던 저는 경유공항에서 그만 지갑을 도둑 맞았었습니다. 전 재산과 카드 등이 있었지만 호주에 도착하고 난 후에야 그사실을 알게 되었고, 밤늦은시각에 도착한 터라 공항에서 잠을 청할수도, 예약해둔 백팩커스에 들어갈 수도 없는 상황이었습니다. 저는 기지를 발휘하여 짧은 영어로 공항내의 무수한 사람들에게 사정이 이러이러한데 꼭 사례를 할테니 돈을 빌려달라고 요청했고, 결국엔 빌리는데 성공하여 무작정 시내로 버스를 타고 들어간 후 시내에서 하루 노숙을 하고, 곧바로 영사관을 찾아가 도움을 청했고, 그 이후로 계좌에 있던 얼마안되는 돈을 찾아 이력서를 만들고 바로 아르바이트를 구했습니다. 결국 그 경험을 통해 무엇이든 마음만 먹고 기지를 발휘한다면 해결해낼수 있다! 라는 마음을 굳게 먹었으며 1년간의 호주 워킹홀리데이를 성공적으로 마무리 할 수 있었습니다. 위의 사례처럼 저는 어렵고 절망적인 일이어도 절대 포기하지않고 끝까지 해내려는것이 저의 강점이라고 생각합니다. 그리고 이 경험을 토대로 여러 프로젝트에서 항상 많은 어려운 일에서도 늘 포기하지 않으며 문제해결 및 기능개발에 힘을 써왔고 그렇기에 트러블슛팅에 적극적인 편입니다.

20. 무엇이 자신을 좋은 팀 플레이어로 만든다고 생각하나요?

    - 저는 아주 지극히도 평범한 사람입니다. 남에게 피해를 끼친다면 그 피해에 대한 보상을 반드시 해야한다고 생각합니다. 그러다보니 두루뭉실하게 어느 조직이든 잘 녹아드는 것을 좋아합니다. 그렇기때문에 팀의 리더가 되면 팀의 리더로써의 역할을 충실히 할수있고, 팀원이 된다면 열심히 리더를 도우며 일을 할 수 있습니다.

21. 비판을 어떻게 처리하나요?

    - 저에게 들어오는 비판에 대해 굉장히 긍정적인 편입니다. 소싯적 막내아들로 자라 꾸지람없이 자란터라 저에게 오는 비판은 매우 귀중합니다. 그렇기에 비판을 적극적으로 수용하는 편이며 반성도 빠르고 무엇보다 피드백도 즉각적으로 들으려 노력하는 편입니다.

22. 문제를 해결하기 위해 주도적으로 행동했던 때를 설명해 주세요.

    - 제가 한 프로젝트에서 팀장을 맡았을 때입니다. 팀원들은 랜덤으로 뽑혔고 각자가 원하는 분야가 있고 구현하고자 하는 기능들이 있었습니다. 최대한 공정하게 직무를 분배하였으나 그 과정에서 팀원 몇분이 마음이 상하셨는지 스크럼회의나 각종질문에도 퉁명스럽고 대답을 잘 안하셨었고, 저는 팀원들을 한데 모아 진행을 맡으며 팀의 분위기를 좋게 이끌고자 매우 노력했고, 결국 모두 오해가 풀려 마지막날까지 같이 게임도 하고 좋은 분위기 속에 프로젝트를 마무리 했습니다.

23. 프로세스와 스레드의 차이에 대해 설명해 보세요.

    - 프로세스는 자원을 할당받는 작업의 단위이며, 스레드는 프로세스가 할당받은 자원을 이용하는 실행의 단위. 스레드는 자원을 공유한다는 점이 차이점이 있습니다.

24. RDB와 NoSQL의 차이에 대해 설명해 보세요.

    - RDBMS는 정해진 스키마가 존재하고, NoSQL는 정해진 스키마가 없다는 것이 가장 큰 차이입니다. NoSQL은 정해진 스키마가 없을 때 데이터 구조 변화가 자유롭고 데이터 분산이 용이하다는 장점이 있지만, 데이터 중복이 발생하거나 데이터 변경 시에 연산이 오래 걸린다는 단점이 있습니다.

25. DB에서 인덱스를 잘 사용하면 어떤 장점이 있을까요?

    - DB의 인덱스를 잘 사용하는 것은 데이터를 검색하는 시점에 성능 차이에 큰 영향을 미칩니다. 대용량 데이터를 담고 있는 DB 테이블에서 필요한 데이터를 빨리 찾기 위해 인덱스가 필요합니다. 인덱스가 없거나 적절한 인덱스를 찾지 못할 경우 데이터가 담겨있는 테이블 전체를 읽어야 하기에 데이터 조회 시간이 오래 걸립니다. 인덱스는 DB 데이터의 주소를 갖고 있는 것을 의미하며, 원하는 데이터를 빠르게 찾을 수 있다는 장점을 가지고 있습니다.

26. 병렬 프로그래밍에 대해 아나요? 프로그래밍을 해본 적이 있나요?

    - 큰 문제를 작게 나누어 동시에 해결할 때 병렬 프로그래밍을 사용합니다. 지원자분께서 멀티 프로세싱 or 멀티 쓰레딩을 구현해 본 경험을 함께 설명할 수 있다면 좋습니다. ex) python의 pthread 라이브러리를 사용한 멀티 스레딩 경험
      추가적으로 병렬 프로그래밍은 큰 문제를 프로세스 혹은 스레드가 나누어 처리를 하기 때문에 처리 속도가 향상된다는 장점을 가지고 있습니다. 단점으로는 구현 난이도가 올라간다는 점입니다. 특히 큰 문제를 일정량씩 나누고, 각 분리된 테스크를 어떻게 배정해서 처리할 것인지에 대한 고민이 필요합니다. 또한, 여러 스레드가 하나의 데이터를 공유한 경우에 아래 8번 문제를 유의해야 합니다.

27. 병렬 프로그래밍을 할 때 어떤 부분을 유의해야 하나요? 세마포어와 뮤텍스에 대해 알고 있나요? 생길 수 있는 문제는?

    - 뮤텍스는 한 스레드, 프로세스에 의해 소유될 수 있는 key를 기반으로 합니다. 반면 세마포어는 현재 공유자원에 접근할 수 있는 스레드, 프로세스의 수를 나타내는 값을 기반으로 합니다. 뮤텍스나 세마포어를 쓰더라도 데드락이 발생할 수 있습니다.

28. 트러블슈팅을 해본 경험이 있나요?

29. 가장 기억에 남는 백엔드 프로젝트의 구조를 그려보세요

30. LRU 캐시에 대해 설명하시오.

    - LRU 캐시는 Least Recently Used 캐시로 캐시 메모리가 다 차면, 가장 오랫동안 사용되지 않았던 캐시를 메모리에서 삭제하는 알고리즘입니다. 캐시를 교체하는 알고리즘이 어떤 것 들이 있는지 이해해두면 좋습니다.

    * 캐시 교체 알고리즘의 종류 예시
      FIFO (first in first out)
      　　LFU (least frequently used)
      　　LRU (least recently used)

31. 연결 리스트에서 값을 찾는데 시간 복잡도가 얼마나 걸리는가? 더 개선된 구조가 있는지? 단점은?

    - O(n)의 시간 복잡도가 걸립니다. 뒤쪽 원소도 빠르게 검색할 수 있는 Doubly Linked List 구조도 있으며, 이는 저장 공간이 더 필요하다는 단점이 있습니다. 그 외에 Circular Linked List 등도 있습니다. 연결 리스트를 수도 코드로 간단하게 구현할 줄도 알면 좋습니다.

    - 수도코드 (한글버전)
      1. 데이터와 다음 데이터의 값을 가진 노드를 생성한다.
         1-1. 새 노드 생성시 다음값으로 null로 가리킨다.
         　 　 1-2. 새 링크드 리스트 생성시 객체를 생성한다.

      2. 링크드 리스트에 맞는 메소드함수를 구현한다.
         2-1. append(data) :
         　 　 　 2-1-1. 헤드가 없으면 헤드 노드를 생성하고 null을 가리킨다.
         　 　 　 2-1-2. 만약 헤드가 null을 가리키면, 헤드가 새로 생성된 데이터를 가리키게 한다.
         　 　 　 2-1-3. 만약 헤드가 다음 데이터를 가르키고 있으면 그 다음 데이터가 새로운 데이터를 가리키게 하고 데이터를 추가한다.
         　 　 2-2. removeAt(location) : 데이터의 위치에 따라 데이터를 삭제한다.
         　 　 　 2-2-1. 삭제하고자 하는 데이터의 이전 데이터가 삭제하고자 하는 데이터의 다음 데이터를 가리키게 하고 삭제할 데이터는 null을 가리키게 한다.
         　 　 　 2-2-2. 만약 리스트의 첫번째를 삭제하려면 헤드를 다음 데이터로 바꾸고 삭제할 데이터를 삭제한다.
         　 　 2-3. indexOf(data) : 데이터를 순서대로 따라가면서 인덱스를 더해준다. 일치하는 데이터를 찾으면 인덱스를 반환한다.
         　 　 2-4. remove(data) : 데이터 값을 기준으로 삭제를 원할 때 인덱스의 값을 찾아 일치하는 값을 removeAt(index)로 삭제한다.
         　 　 2-5. insert(location, data) : 원하는 위치에 데이터를 추가할 때 인덱스 값을 기준으로 위치를 찾고 데이터를 추가한다.
         　 　 2-6. isEmpty() : 자료의 수가 0 이상이면 false를 반환한다.
         　 　 2-7. length() : 리스트내 전체 자료의 수를 반환한다.

32. 스택 2개를 활용해서 Queue처럼 가동하는 클래스를 만들어보세요.

    - 예를 들어 1 2 3 4를 큐에 넣으면 순서대로 1 2 3 4가 나옵니다. 이를 선입선출이라고 합니다. 하지만 스택은 1 2 3 4를 넣으면, 4 3 2 1이 나옵니다. 스택은 큐와 다르게 선입후출의 구조입니다. 하지만, 스택 2개를 활용하는 경우. 2번째 스택에 아무것도 없는 상태에서 pop를 수행한다면 첫 번째 스택에 쌓여있는 값을 2번째 스택으로 이관시킬 수 있습니다.

33. CI/CD란? 적용해 본 적이 있나요?

    - CI/CD란 서비스 빌드부터 배포까지의 과정을 자동화하는 과정입니다. github로 코드 커밋 했을 때 해당 동작을 감지하여 jenkins 가 자동으로 빌드하도록 설계해 본 경험이 있다 등의 경험을 함께 이야기하면 좋습니다.

34. 마이크로 서비스와 모놀리틱 서비스의 차이

    - 마이크로 서비스는 개별 서비스 단위로 개발하는 방식이고, 모놀리틱 서비스는 하나의 통합된 패키지로 개발하는 방식입니다. 마이크로 서비스는 개별 서비스 단위로 나누어져 있어 해당 부분만 수정 및 배포하기에 좋고, 필요한 부분만 확장하기에도 용이하다는 장점이 있습니다.

35. 배포 로직 설명하기 (헤로쿠, aws)

36. csr과 ssr 차이

    - **S**erver **S**ide **R**endering의 약자

      - 말 그대로 서버쪽에서 렌더링 준비를 끝마친 상태로 클라이언트에 전달하는 방식이다.
      - User가 Website 요청을 보냄.
      - Server는 'Ready to Render'. 즉, 즉시 렌더링 가능한 html파일을 만든다.
        (리소스 체크, 컴파일 후 완성된 HTML 컨텐츠로 만든다.)
      - 클라이언트에 전달되는 순간, 이미 렌더링 준비가 되어있기 때문에 HTML은 즉시 렌더링 된다. 그러나 사이트 자체는 조작 불가능하다. (Javascript가 읽히기 전이다.)
      - 클라이언트가 자바스크립트를 다운받는다.
      - 다운 받아지고 있는 사이에 유저는 컨텐츠는 볼 수 있지만 사이트를 조작 할 수는 없다. 이때의 사용자 조작을 기억하고 있는다.
      - 브라우저가 Javascript 프레임워크를 실행한다.
      - JS까지 성공적으로 컴파일 되었기 때문에 기억하고 있던 사용자 조작이 실행되고 이제 웹 페이지는 상호작용 가능해진다.

    - **C**lient **S**ide **R**endering의 약자

      - 말 그대로 SSR과 달리 렌더링이 클라이언트 쪽에서 일어난다.
        즉, 서버는 요청을 받으면 클라이언트에 HTML과 JS를 보내준다. 클라이언트는 그것을 받아 렌더링을 시작한다.
      - User가 Website 요청을 보냄.
      - CDN이 HTML 파일과 JS로 접근할 수 있는 링크를 클라이언트로 보낸다.
      - [CDN](https://ko.wikipedia.org/wiki/콘텐츠_전송_네트워크) : aws의 cloudflare를 생각하면 됨. 엔드 유저의 요청에 '물리적'으로 가까운 서버에서 요청에 응답하는 방식
      - 클라이언트는 HTML과 JS를 다운로드 받는다.
        (이때 SSR과 달리 유저는 아무것도 볼 수 없다.😡)
      - 다운이 완료된 JS가 실행된다. 데이터를 위한 API가 호출된다.
        (이때 유저들은 placeholder를 보게된다. )
      - 서버가 API로부터의 요청에 응답한다.
      - API로부터 받아온 data를 placeholder 자리에 넣어준다. 이제 페이지는 상호작용이 가능해진다.

    - 웹페이지를 로딩하는 시간

      - 웹 페이지 로딩의 종류는 두 가지로 나눌 수 있다.
        하나는 웹 사이트의 가장 **첫 페이지**를 로딩하는 것.
        다른 하나는 **나머지**를 로딩하는 것

      - 첫 페이지 로딩시간

      - CSR의 경우 HTML, CSS와 모든 스크립트들을 한 번에 불러온다. 반면 SSR은 필요한 부분의 HTML과 스크립트만 불러오게 된다. 따라서 평균적으로 SSR이 더 빠르다.

      - 나머지 로딩 시간

      - 첫 페이지를 로딩한 후, 사이트의 다른 곳으로 이동하는 식의 동작을 가정하자. CSR은 이미 첫 페이지 로딩할 때 나머지 부분을 구성하는 코드를 받아왔기 때문에 빠르다.
        반면, SSR은 첫 페이지를 로딩한 과정을 **정확하게** 다시 실행한다. 그래서 더 느리다.

      - SEO 대응

      - 검색 엔진은 자동화된 로봇인 '크롤러'로 웹 사이트들을 읽는다. CSR은 자바스크립트를 실행시켜 동적으로 컨텐츠가 생성되기 때문에 자바스크립트가 실행 되어야 **meatadata**가 바뀌었다.
        (이전 크롤러들은 자바스크립트를 실행시키지 않았었기에 SEO 최적화가 필수적이었다. 구글이 그 트렌드를 바꾸고 있다고 한다.)

        SSR은 애초에 서버 사이드에서 컴파일되어 클라이언트로 넘어오기 때문에 크롤러에 대응하기 용이하다.

      - 서버 자원 사용

      - SSR이 서버 자원을 더 많이 사용한다. 매번 서버에 요청을 하기 때문이다.

    - SSR을 사용하자

      - 네트워크가 느릴 때 😓
        (CSR은 한번에 모든 것을 불러오지만 SSR은 각 페이지마다 나눠불러오기 때문)
      - SEO(serach engine optimization : 검색 엔진 최적화)가 필요할 때.
      - 최초 로딩이 빨라야하는 사이트를 개발 할 때
      - 메인 스크립트가 크고 로딩이 매우 느릴 때CSR은 메인스크립트가 로딩이 끝나면 API로 데이터 요청을 보낸다. 하지만 SSR은 한번의 요청에 아예 렌더가 가능한 페이지가 돌아온다.
      - 웹 사이트가 상호작용이 별로 없을 때.

    - CSR을 사용하자

      - 네트워크가 빠를 때
      - 서버의 성능이 좋지 않을 때
      - 사용자에게 보여줘야 하는 데이터의 양이 많을 때.
        (로딩창을 띄울 수 있는 장점이 있다.)
      - 메인 스크립트가 가벼울 때
      - SEO 따윈 관심 없을 때😤
      - 웹 어플리케이션에 사용자와 상호작용할 것들이 많을 때. (아예 렌더링 되지 않아서 사용자의 행동을 막는 것이 경험에 오히려 유리함.)

37. Django에서 미들웨어의 기능은 무엇인가?

    - http 요청 / 응답 처리 중간에서 작동하는 시스템이다

    - DJango는 **http 요청**이 들어오면 미들웨어를 거쳐서 해당 URL에 등록되어 있는 뷰로 연결해주고, **http 응답** 역시 미들웨어를 거쳐서 내보낸다

    - 따라서 Django에서 **미들웨어**는 http 요청 혹은 응답의 전처리에 사용이 된다

    - 미들웨어를 등록하는 방법은 setting.py에서 `MIDDLEWARE` 항목에 추가하고자 하는 미들웨어의 **full python path**를 추가해주면 된다

    - django-admin startproject 명령어로 django project를 생성하면 기본적으로 미들웨어들이 등록되어 있다

    - ### 미들웨어 순서

      - 미들웨어 등록시 가장 중요한 것은 미들웨어를 등록하는 순서이다
      - 미들웨어 등록 순서가가지는 의미는 다음과 같다
        - http request가 들어오면 **위에서부터 아래로** 미들웨어를 적용시킨다
        - http response가 나갈 때 **아래서부터 위로** 미들웨어를 적용시킨다

    - ### 커스텀 미들웨어 작성하기

      - Django에서 커스텀 미들웨어는 함수나 클래스로 작성할 수 있다

    - #### 함수로 작성하기

      - 미들웨어를 함수로 작성하게 될 경우에는 **팩토리 형식**을 사용한다
      - `my_middleware`는 `get_response` 함수를 받는 하나의 함수이며, `middleware` 라는 내부 함수를 반환하게 된다
      - `my_middleware` 함수 상단에서는, 최초 설정 및 초기화를 진행하게 된다
      - `middleware` 라는 내부 함수에서는, request를 받아서 최종적으로 response를 반환한다
      - 이 함수는, 중간의 `get_response` 함수를 호출하기 전과 후로 나눠서 생각할 수 있는데, view가 호출되기 전과 view가 호출되고 난 후 처리할 일들을 나누어서 작성해 주면 된다

    - #### 클래스로 작성하기

      - 클래스로 미들웨어를 작성하게 되면 보다 더 구조화된 미들웨어를 작성할 수 있게 된다

    - 

38. Django에서 MVT 아키텍처는 무엇인가?

39. Django MODEL에서 모든 아이템을 리턴하려면 어떻게 해야하는가?

40. Django MODEL에서 id가 1인 것만 리턴하려면 어떻게 해야하는가?

41. 파이썬의 스레드에 대해 설명해주세요

42. is 와 '=' 차이는 무엇인가?

43. fetch와 axios의 차이

44. API란?

    - **API는 “**Application Programming Interface”의 준말. 풀이를 하자면, 여러 **프로그램들과 데이터베이스, 그리고 기능들의 상호 통신 방법을 규정하고 도와주는 매개체이다.** API는 데이터베이스가 아니지만, 액세스 권한이 있는 앱의 권한 규정과 “서비스 요청”에 따라 데이터나 서비스 기능을 제공하는 메신저 역할을 한다.

      그럼 왜 그냥 데이터베이스를 연결하지 굳이 이런 매개체가 필요한가? 

      #### Web의 진화와 API

      API의 필요성은 Web의 진화와 밀접한 연관이 있으니 잠깐 살펴보면, 모놀리틱 아키텍처(Monolithic Architecture)가 주도적이었던 Web 1.0 시대에서는 (하지만 현재에도 사실 많이 쓰이고 있는 것이 사실!) 서버와 클라이언트가 분리되지 않고 모두 서버에서 동시에 처리하기 때문에 API 필요성이 그다지 절실하지 않았다.

      그러나 2000년경부터 시작된 Web2.0의 “개방, 참여, 공유”의 정신을 바탕으로 정보가 쌍방향으로 소통하고 “사용자가 생성한 데이터”를 위주로 웹 앱의 붐, 그리고 2010년대 들어서 클라우드(Cloud) 기반 인프라와 MSA(Microservices Architecture)의 사용이 확산되면서 API 확산이 가속화되었고 이제 API에서 가장 흔한 구조인 REST 또는 RESTful API가 점차 새로운 웹 생태계의 기반으로 주목된 것이다.

      API를 개인적으로는 이렇게 이해한다: “**request-to-serve**”, 한마디로 “각자 권한 분야에서 각자 필요한 것만 연계하기(철저한 개인주의 따로국밥?)”를 가능하게 해주는 서비스.

      ### API의 장점

      #### **데이터 접속의 표준화와 편의성**

      위의 접근 방식에 따른 public API와 partner API 등의 종류들에서 알아봤듯이 API는 모든 접속을 표준화하기 때문에 디바이스/운영체제 등과 상관없이 조건만 맞다면, 말하자면 범용 플러그처럼 누구나 동일한 액세스를 약속한다. 또 조직에서 애플리케이션을 개발할 때 기능적 API를 사용하면, 필요한 기본 기능들– 인증, 통신, 지불 처리 및 위치 확인 등–을 매번 자가 개발/업데이트할 필요 없이 손쉽게 이용할 수 있는 장점이 있다. 즉, 더 이상 수레바퀴를 만들 때마다 매번 재발명할 필요가 없다.

      #### **자동화와 확장성**

      API를 통한 CRUD 처리에 따라 관련 데이터와 콘텐츠가 자동으로 생성되고 사용자의 환경에 맞춰서 정보가 전달 되어 개발 워크플로우가 간소화되고 애플리케이션 확장이 다소 용이하다. 예를 들자면 API를 활용한 웹 사이트 분석, 프로젝트 및 팀 관리 도구, 온라인 결제 시스템, 기타 여러 운영 설루션에 필요한 애플리케이션을 다소 쉽게 작성 가능하다.

      #### **적용력**

      API는 변화 예측에도 큰 도움이 되기 때문에 API를 통해 데이터를 수집하고 전달하는 데 있어 유연한 서비스 환경을 구축하고 소프트 웨어를 통합하고자 할 때, 그리고 개발자들 간의 협업이 필요할 때 더욱 용이하다.

      ### API의 단점

      #### **보안성과 HTTP 방식의 제한**

      가장 주목할 것은 API의 단일 진입점인 API 게이트웨이는 해커의 타겟 대상이 될 수 있다는 점이다. 한마디로 API의 장점– 평범한 HTTP 메서드를 사용하여 액세스 할 수 있다는 점–이, 보안성에 관해서는 반면 크나큰 단점이 된다. 이 때문에 다른 일반적 인터넷 기반 리소스와 마찬가지로 메시지 가로채기 공격(man-in-the-middle), CSRF(Cross-Site Request Forgery) 공격, 크로스 사이트 스크립팅(Cross Site Scripting, XSS), SQL 삽입 공격(SQL injection), DDoS(Denial-of-service attack) 공격 (서비스 거부 공격) 등에 취약한 것이 사실이다. 또한 이러한 HTTP method는 메서드 형태가 다소 제한적이라는 문제점이 있다.

      **API 보안에 대한 참고 정보 링크**: [https://www.redhat.com/ko/topics/security/api-security#%EA%B0%9C%EC%9A%94](https://www.redhat.com/ko/topics/security/api-security#개요)

      #### **표준의 부재와 개발 비용**

      REST API의 설계에 있어 가장 큰 단점이라고 할 수 있는 점이 공식화된 표준이 존재하지 않는다는 점이다. 그러므로 관리가 어렵고 실제로 API 기능을 구현하고 제공하려면 개발 시간, 지속적인 유지 관리 요구 사항 및 지원 제공 측면에서 비용이 많이 들 수 있다. 또한 기존 API의 기능을 확장하려고 할 때 광범위한 프로그래밍 지식이 필요하다.

45. redis란?

46. 도메인이란?

    - 인터넷에 연결되어있는 장치들은 각각의 장치를 식별할 수 있는 주소(ip)를 가지고 있다
    - ip는 사람이 이해하고 기억하기 어렵기 때문에 이를 위해 각 ip에 이름을 부여할 수 있게 했는데, 그것을 도메인이라고 한다.
    - 도메인의 구성요소
      - opentutorials
        - opentutorials : 컴퓨터의 이름
        - org : 최상위 도메인 - 비영리 단체
      - daum.co.kr
        - daum : 컴퓨터의 이름
        - co : 국가 형태의 최상위 도메인
        - kr : 대한민국의 NIC에서 관리하는 도메인
    - URL의 이해
      - 도메인은 장치를 식별하기 위한 주소
      - URL은 도메인 + 경로
      - 예를들어 http://opentutorials.org/user/module/121/298.png 가 있을때
        - 도메인 : opentutorials.org
        - URL : http://opentutorials.org/user/module/121/298.png

47. 쿠키 / 세션

48. 로그인 로직 설명하기

49. CRUD 로직 설명하기

50. 비동기 / 동기

51. 싱글스레드 / 멀티스레드

52. 라이브러리 와 프레임워크 차이점

53. 오버로딩(Overloading)과 오버라이딩(Overriding)의 차이점

54. 지금 사용언어의 장점/이유는? 

55. Session과 Cookie 사용 이유는?

56. MVC 패턴, MTV 패턴

57. Static의 의미 

58. Framework

59. Framework 경험해 보았나요? 

60. Thread

61. Database에서 Index란?

62. 추상클래스와 인터페이스의 차이점

63. SQL 문법 정리

64. Framework와 라이브러리의 차이점

65. 

