## 1. 10430번 - 나머지

언급하지 않겠습니다!



## 2. 4375번 - 1

```python
# 빈 문자열
ans = ""

# 지속적으로 추가할 문자
k = "1"
ans += k

# 해당 n값으로 나누어지는지 판별
```



## 3. 1037번 - 약수, 17427번 - 약수의 합, 2609번 - 최대 공약수 와 최소 공배수



언급 하지 않겠습니다!



## 4. 1978번 - 소수 찾기, 1929번 - 소수 구하기,  6588번 - 골드바흐의 추측



```python
# 에라토스테네스의 체를 활용한다.

# base code
p = 10 ** 6
prime = [False, False] + [True] * (p - 1)

for i in range(2, p + 1):
    if prime[i]:
        for j in range(2, p + 1, i):
            prime[j] = False
```





## 5. 팩토리얼 0의 개수, 팩토리얼

```python
# 메모제이션을 활용하라! (위 두 문제는 N값이 작다. 하지만 N값이 더 커질 경우 시간복잡도에서 시간초과를 맞을수 있는 것을 대비)

# base code
dp = [1] * (501)

for i in range(2, 501):
    dp[i] *=  dp[i - 1];

print(dp[n])
```



## 6. 조합 0의 개수

```python
# n이 가지고 있는 2의 지수 와 5의 지수 중 작은 값을 찾아라

# base code

def cal(n, k):
    cnt = 0
    
    while n:
        n //= k
        cnt += a
    return cnt
```



## 7. GCD 합

브루트포스 입니다. 모든 경우의수!! 다돌리면 됩니다.



## 8. 소수인팰린드롬

```python
# 에라토스테네스의 체를 활용!
# 에라토스테네스의 체 베이스 코드 안에서 팰린드롬인지 아닌지 판별하라(이 문제의 핵심)

# base code
p = 10 ** 6
prime = [False, False] + [True] * (p - 1)

for i in range(2, p + 1):
    if prime[i]:
        for j in range(2, p + 1, i):
            prime[j] = False
```



## 9. 2×n 타일링

```python
# dp를 배우기 위한 좋은 기본 문제이다.
# dp에는 반드시 점화식(규칙)이 존재한다. -> 찾는 것이 핵심!!
# 위 문제는 반드시 2 * n 타일링을 채울 경우의수를 그리면 점화식이 보인다.
# n값에 따라 경우의수를 저장해둬라 (메모제이션) -> top-down, bottom-up 방식이 있다!! 찾아보면 어떤것이 알 수있다.
```



## 10. N과 M (1)

```python
# 본격적인 combination 과 permutation를 활용한다.
# 라이브러리를 활용할 것인가, 활용 안하고 코드로 구현 할것인가!
# 코드로 구현 하게 된다면 응용이 가능하다.

# base code

import sys

inp = lambda: map(int, sys.stdin.readline().split())

def back():
    if len(answer) == m: # 전역 변수 이기 때문에 함수 내에서 활용이 가능하다.
        print(*answer)
        return
    for i in range(1, n + 1):
        if not i in answer:
            answer.append(i)
            back()
            answer.pop()
n, m = inp()
answer = []
back()
```



## 11. 수 이어 쓰기 1

```python
# 주어 지는 n값이 백의 자리 수라면 규칙을 통해서 십의 자리수 개수 파악한다.
# 필요한 백의 자리수 값 까지 자리수를 계산한다.

# base code
while p < k:
    ans += 9 * (10 ** p) * (p + 1)
    p += 1
ans += (int(n) - (10 ** p) + 1) * (k + 1)
print(ans)
```



## 달팽이

```python
# 현재 내려 가는 방향인지, 오른쪽으로 가는 방향인지, 어느 방향인지 파악이후 움직인다.(핵심)
# 내려 가는 방향이 끝날 때, 올라 가는 방향이 끝 날때는 넣어할 숫자의 개수가 줄어든다.(규칙)

# 4방향으로 이동하기 위한 값!
dx = [1, 0, -1, 0]
dy = [0, 1, 0, -1]

# 입력
n = int(input())

# 찾는 값
f_n = int(input())

# 달팽이를 만들기위한 이중 배열 및 f_n 찾고자하는 값의 위치를 넣기 위한 [[0, 0]] 추가
arr = [[0] * n for _ in range(n)] + [[0, 0]]

# 현재 방향
d = -1
# 넣어야 할 k값
k = n * n

# 현재 위치
x, y = -1, 0

for _ in range(n * 2 - 1):
    # 현재 방향
    d = (d + 1) % 4
    
    # 현재 방향에 맞게 값을 더해준다.
    for _ in range(n):
        
        x += dx[d]
        y += dy[d]
        # 현재 위치 값에 해당하는 k 값
        arr[x][y] = k
        # f_n 의 위치
        if k == f_n:
            arr[-1][0] = x + 1
            arr[-1][-1] = y + 1
        k -= 1
    # 아래로, 위로 끝났으니 n 값 줄이기
    if not d or not d % 2:
        n -= 1
for i in range(len(arr)): print(*arr[i])
print(*ans[0])
```

