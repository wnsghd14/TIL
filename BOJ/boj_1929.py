a, b = map(int,input().split())

for i in range(a,b+1): # 값을 맞추기 위함.
    if i == 1: # 1은 소수가 아니다.(혹시나 있을경우를 대비)
        continue
    for j in range(2, int(i**0.5)+1): # 반만 뜯어보는 것이다. 짝수이기때문에 가능한것!
        if i % j == 0: # 약수가 존재한다면 소수가 아니다.
            break # 멈춤
    else: # 1이아닌 모든 소수들을 프린트
        print(i)

# 에라토스테네스의 체
# 소수 판별 알고리즘 이다. 특정한 숫자의 제곱근 까지만 약수의 여부를 검증하는 방식.
# 일반적인 소수 판별 알고리즘의 시간복잡도를 죽여주어 시간이 단축된다.
# 2부터 소수를 구하고자 하는 구간의 모든 수를 나열한다. 
# 그림에서 회색 사각형으로 두른 수들이 여기에 해당한다.
# 2는 소수이므로 오른쪽에 2를 쓴다. (빨간색)
# 자기 자신을 제외한 2의 배수를 모두 지운다.
# 남아있는 수 가운데 3은 소수이므로 오른쪽에 3을 쓴다. (초록색)
# 자기 자신을 제외한 3의 배수를 모두 지운다.
# 남아있는 수 가운데 5는 소수이므로 오른쪽에 5를 쓴다. (파란색)
# 자기 자신을 제외한 5의 배수를 모두 지운다.
# 남아있는 수 가운데 7은 소수이므로 오른쪽에 7을 쓴다. (노란색)
# 자기 자신을 제외한 7의 배수를 모두 지운다.
# 위의 과정을 반복하면 구하는 구간의 모든 소수가 남는다